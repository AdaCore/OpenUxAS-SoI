#|

GE CONFIDENTIAL INFORMATION © 2016 General Electric Company 
-- All Rights Reserved. 

AUTHOR: Pete Manolios
        Harsh Raju Chamarthi

VERSION: 2017-07-06.

To robustly fix AATIM-1997, write all xml messages to a string and at
the very end add the XML headers. For incremental RAE analyses and
incremental results we write xml messages for each controlled variable
cvar separately in its own cvar.err file.

VERSION: 2017-6-27.

RAE release version.

VERSION: 2017-6-19.

- Reverted back to old names. 
  .sout has RA related summary output, instead of .results.
  .eout is further restricted to error msgs.
  Reason: To support error.xml generation without interfering with Py
  scripts I need to use different file names.
- Added a new flag to enable/disable even the main output stream.
- Renamed main function and added an iteration function.
- removed rae-settings load since it is not used.

VERSION: 2017-6-12.

Filter XML error messages and write to error.xml.

VERSION: 2016-9-22.

After discussions with Anthony Shephard, I updated this file so
that the Tools team can use it instead of using their python
code.

To allow that, I changed the output file names that contain the
ACL2s output to ".log", instead of ".out" so that we're both
using the same file extension.  I also changed the file extension
of the files this code generates to ".results" instead of ".sout"
for the same reason.

I also updated the code so that it works in the case that
the ".log" file was generated by running
"process-all-analyses" instead of "run-all-analyses".
It was hard to exactly replicate what the tools team is doing
since there have been a lot of changes to
requirements-analysis-book, but I tested it on an existing .log
file and that seemed to work fine.

I added a flag that determines whether to generate the ".eout"
files containing only the **Emsg** output. By default I do
generate this file.

I updated the code so that instead of storing the output string
explicitly, I just directly write it to the output file a line at
a time. As a result of this change, I got rid of the parameters
*summary* and *esummary*.

Finally, I stripped out the **RMsg** and **EMsg** headers and
footers.  That's not really useful information for the end user.
In fact, I rewrote the requirements-analysis-book code so that
the **RMsg** and **EMsg** delimeters appear on a separate line by
themselves, which makes the code a little cleaner.

VERSION: 2016-9-15.

This is an updated version of rmsg-summary.lsp that takes
advantage of the updated usability improvements.  We print out a
smart, clear summary to a .sout file consisting of all all the
requirements analysis messages of the form

**XX** Starting ... analyses.**XX**

**XX** ... analyses completed successfully.**XX**

**RMsg**: ... analysis.   
...
!!RMsg!!

**EMsg**: ... analysis.   
...
!!EMsg!!

The difference with rmsg.lsp is that there we tried to parse the
output of the theorem prover to extract useful messages. Now, we
have re-architected the analyses so that we have direct access to
the data we need to print out whatever reports we want. See
rmsg.lsp for more information on the previous version of the tool
and see the requirements analysis books for more information on
how we gain direct access to the data we need.

We also print out just error messages to an .eout file. 

To the tools team: You should switch over to using this instead
of rmsg.lsp.

|#

; :q


; Parameters to determine whether to generate various output files. 
; The default is yes (t). If we want to advertise this, then I should
; print out enough information for the emsg file to be self
; contained. In particular, it should mention the analysis and
; the expression/requirement(s) the analysis was performed
; on. This needs to happen in requirements-analysis-book.

(defparameter *generate-msg-file* t)
(defparameter *generate-emsg-file* t)
(defparameter *generate-xmlmsg-file* t)

(defparameter *in-rmsg* nil)
(defparameter *in-emsg* nil)
(defparameter *in-xmlmsg* nil)


(defun emsg-out (val estream)
  (when *generate-emsg-file*
    (format estream "~%~a" val)))

(defun irmsg-out (val ostream)
  (when *generate-msg-file*
    (format ostream "~%~a" val)))

(defun xrmsg-out (val ostream)
  (when *generate-msg-file*
    (format ostream "~2%~a~%" val)))

(defun remsg-out (val ostream estream)
  (when *generate-msg-file*
    (format ostream "~%~a" val))
  (emsg-out val estream))

(defun xmlmsg-out (val xstream)
  (format xstream "~%~a" val))

(defun gen-reqid-xml-string (req-ids)
  ;; Given a list of requirement ids (reqs-ids), say R1, R2, R3,
  ;; generate the following string:
  ;; "  <ObjectID>R1</ObjectID>
  ;;    <ObjectID>R2</ObjectID>
  ;;    <ObjectID>R3</ObjectID>"
  (if (endp req-ids)
      ""
    (let ((req-name (acl2s::strip-req-name (car req-ids))))
    (concatenate 'string
                 "<ObjectID>" req-name "</ObjectID>"
                 (gen-reqid-xml-string (cdr req-ids))))))

(defparameter *curr-req-names* nil)
(defparameter *curr-controlled-variable* nil)



(defun collect-req-names/line (val)
  (trivia:match val
    ;; (SET-RAE-TBL-SRL-REQUIREMENTS-LIST '(REQ188))
    ((list 'SET-RAE-TBL-SRL-REQUIREMENTS-LIST (list 'QUOTE req-list))
     (setf *curr-req-names* (append *curr-req-names* req-list)))
    ;; (SET-RAE-TBL-SRL-ASSUMPTIONS-LIST 'NIL)
    ((list 'SET-RAE-TBL-SRL-ASSUMPTIONS-LIST (list 'QUOTE assum-list))
     (setf *curr-req-names* (append *curr-req-names* assum-list)))
    ;; (SET-RAE-TBL-SRL-CONTROLLED-VARIABLE '|received of GUIDANCE|)
    ((list 'SET-RAE-TBL-SRL-CONTROLLED-VARIABLE (list 'QUOTE cvar))
     (setf *curr-controlled-variable* cvar))))
    

    
(defun collect-req-names (filename)
  (let ((filename (if (and (> (length filename) 5)
                           (equal (subseq filename (- (length filename) 5))
                                  ".lisp"))
                      filename
                    (concatenate 'string filename ".rae.lisp"))))
    (setf *curr-controlled-variable* nil)
      (setf *curr-req-names* nil)
      (with-open-file (istream filename :direction :input)
                      (loop
                       for val = (read istream nil :eof)
                       until (eq val :eof)
                       do (collect-req-names/line val)))))
        
         
(defun process-line- (val filename ostream estream xstream)
  (cond (*in-emsg*
         (remsg-out val ostream estream))
        (*in-rmsg* 
         (irmsg-out val ostream))
        (*in-xmlmsg*
         (xmlmsg-out val xstream))
        ((>= (length val) 27)
         (when (string= val "ACL2 Error in (CERTIFY-BOOK" :start1 0 :end1 27)
           (collect-req-names filename)
           (xmlmsg-out
            (concatenate
             'string 
             "<Marker markerType=\"Warning\"" " "
             "msgName=\"Potential type-checking error\" "
             "
"
             "msgText=\""
             "RAE: No analysis was performed for this requirement due to a certification failure.
Controlled Variable: "
             (acl2s::strip-req-name *curr-controlled-variable*)
             ".
For more details see log file "
             filename
             "\">"
             (gen-reqid-xml-string *curr-req-names*)
             "</Marker>")
            xstream)))
        ((>= (length val) 6)
         (when (string= val "**XX**" :start1 0 :end1 6)
           (xrmsg-out val ostream)))
        ))

(defun process-line (val filename ostream estream xstream)
  (let ((l (length val)))
    (cond ((and (>= l 8) (string= val "!!RMsg!!" :start1 0 :end1 8))
           (setf *in-rmsg* nil))
          ((and (>= l 8) (string= val "!!EMsg!!" :start1 0 :end1 8))
           (setf *in-emsg* nil))
          ((and (>= l 10) (string= val "!!XmlMsg!!" :start1 0 :end1 10))
           (setf *in-xmlmsg* nil))
          ((and (>= l 8) (string= val "**RMsg**" :start1 0 :end1 8))
           (setf *in-rmsg* t))
          ((and (>= l 8) (string= val "**EMsg**" :start1 0 :end1 8))
           (progn
             (remsg-out "" ostream estream)
             (remsg-out "**Error Identified**" ostream estream)
             (setf *in-emsg* t)))
          ((and (>= l 10) (string= val "**XmlMsg**" :start1 0 :end1 10))
           (setf *in-xmlmsg* t))
          (t (process-line- val filename ostream estream xstream)))))


(defun reset-params ()
  (setf *in-rmsg* nil)
  (setf *in-emsg* nil)
  (setf *in-xmlmsg* nil)
  )

(defconst *error-xml-header-start*
  (concatenate 'string
               "<?xml version=\"1.0\" encoding=\"utf-8\"?>
<MarkerService xmlns=\"urn:com:ge:aviation:rce:markerservice\">
  <Process name=\"Requirements Analysis Engine\" build=\""
               ACL2S::*RequirementsVersionNumber*
               "\" pn=\"\">"))

(defconst *error-xml-header-end*
  "
</Process>
</MarkerService>")

;; (filter-remsg-output string) -> output
(defun filter-remsg-output (file)
  (let ((ifile (format nil "~a.log" file))
        (ofile (format nil "~a.sout" file))
        (efile (format nil "~a.eout" file))
        (xstring (make-array '(0) :element-type 'base-char
                             :fill-pointer 0 :adjustable t)))
    (progn
      (reset-params)
      (with-open-file (istream ifile :direction :input)
        (with-open-file (ostream ofile :direction :output :if-exists :supersede)
          (with-open-file (estream efile :direction :output :if-exists :supersede)
;            (with-open-file (xstream xml-file :direction :output :if-exists :append)
            (with-output-to-string (xstream xstring) ;;build xstring
              (do ((val (read-line istream nil :eof)
                        (read-line istream nil :eof)))
                  ((equal val :eof) nil)
                (process-line val file ostream estream xstream))))))
      (with-open-file (xstream (format nil "~a.err" file) :direction :output :if-exists :supersede)
                      (when *generate-xmlmsg-file*
                        (progn 
                          (format xstream "~a" *error-xml-header-start*)
                          (format xstream "~a" xstring)
                          (format xstream "~a" *error-xml-header-end*)))))))

#| 
Usage:
(filter-remsg-output "light_state_LIGHT5")

|#


;; (filter-remsg-output-lst strings) -> output
(defun filter-remsg-output-lst (files &optional out-p err-p xml-p)
  (progn
    (setf *generate-msg-file* out-p)
    (setf *generate-emsg-file* err-p)
    (setf *generate-xmlmsg-file* xml-p)
    (dolist (file files)
      (filter-remsg-output file))))
#| 
Usage:
(filter-remsg-output-lst (list "light_state_LIGHT5" "light_state_LIGHT6" "light_state_LIGHT7") nil nil t)

|#

