Specification Three_Vehicles

Imports:
import "DecentPerimSurvDefs.spear"

Constants:
N : int = 3 //number of vehicles in this case

Inputs:
initial_pos_UAV1 : positionT
initial_direction_UAV1 : signT
initial_pos_UAV2 : positionT
initial_direction_UAV2 : signT
initial_pos_UAV3 : positionT
initial_direction_UAV3 : signT

Outputs:
pos_UAV1 : positionT 
pos_UAV2 : positionT
pos_UAV3 : positionT  

State:
direction_UAV1 : signT
direction_UAV2 : signT
direction_UAV3 : signT
time : timeT

goal_UAV1 : positionT
goal_UAV2 : positionT
goal_UAV3 : positionT

Macros:
//Shared border positions
S_12 : positionT = real(1)*P_global/real(N)  
S_23 : positionT = real(2)*P_global/real(N)
 
//Previous positions
pre_pos_UAV1 : positionT = previous pos_UAV1 with initial value initial_pos_UAV1
pre_pos_UAV2 : positionT = previous pos_UAV2 with initial value initial_pos_UAV2
pre_pos_UAV3 : positionT = previous pos_UAV3 with initial value initial_pos_UAV3

//Previous directions
pre_direction_UAV1 : signT = previous direction_UAV1 with initial value initial_direction_UAV1
pre_direction_UAV2 : signT = previous direction_UAV2 with initial value initial_direction_UAV2
pre_direction_UAV3 : signT = previous direction_UAV3 with initial value initial_direction_UAV3

//Previous goals
pre_goal_UAV1 : positionT = previous goal_UAV1 with initial value (if direction_UAV1 == 1 then P_global else 0.0 m)
pre_goal_UAV2 : positionT = previous goal_UAV2 with initial value (if direction_UAV2 == 1 then P_global else 0.0 m)
pre_goal_UAV3 : positionT = previous goal_UAV3 with initial value (if direction_UAV3 == 1 then P_global else 0.0 m)


//Times to reach neighbors													)
time_to_reach_neighbor_12 : timeT = time_to_reach_neighbor(pre_direction_UAV1,
															pre_direction_UAV2,
															pre_pos_UAV1,
															pre_pos_UAV2
															)
															
time_to_reach_neighbor_23 : timeT = time_to_reach_neighbor(pre_direction_UAV2,
															pre_direction_UAV3,
															pre_pos_UAV2,
															pre_pos_UAV3
															)
//Times to reach endpoints and shared borders
time_until_UAV1_reaches_goal : timeT = time_to_reach_target_position(pre_direction_UAV1, pre_pos_UAV1, pre_goal_UAV1)
time_until_UAV2_reaches_goal : timeT = time_to_reach_target_position(pre_direction_UAV2, pre_pos_UAV2, pre_goal_UAV2)
time_until_UAV3_reaches_goal : timeT = time_to_reach_target_position(pre_direction_UAV3, pre_pos_UAV3, pre_goal_UAV3)

//These Booleans are true iff the neighbors meet (i.e., are co-located) on this timestep.
meet_neighbor_12 : bool = (pos_UAV1 == pos_UAV2) 
meet_neighbor_23 : bool = (pos_UAV2 == pos_UAV3) 

deltaT : timeT = min_time(time_until_UAV1_reaches_goal,
					min_time(time_until_UAV2_reaches_goal,
						min_time(time_until_UAV3_reaches_goal,
							min_time(time_to_reach_neighbor_12,
								time_to_reach_neighbor_23))))
							

Assumptions:
//Assume UAVs are numbered according to position (by definition)
a00 : initial_pos_UAV1 <= initial_pos_UAV2
a01 : initial_pos_UAV2 <= initial_pos_UAV3  

Requirements:
//The next time is the previous time plus the minimum time until a decision/change is made.
r0 : time == (0.0 s -> previous time + deltaT)

r11 : direction_UAV1 == if meet_neighbor_12
						then if pos_UAV1 < S_12
								then 1
								else //pos_UAV1 >= S_12 
									-1
						else if pos_UAV1 <= 0.0 m
								then 1
								else pre_direction_UAV1
						
r12 : direction_UAV2 == if meet_neighbor_12
							then if pos_UAV2 <= S_12
								then 1
								else //pos_UAV2 > S_12
									-1						
							else if meet_neighbor_23
								then if pos_UAV2 < S_23
									then 1
									else //pos_UAV2 >= S_23
										-1 
								else pre_direction_UAV2 


r13 : direction_UAV3 == if meet_neighbor_23
						then if pos_UAV3 > S_23
								then -1
								else //pos_UAV3 <= S_23 
									1
						else if pos_UAV3 >= P_global
							then -1
							else pre_direction_UAV3 

r21 : pos_UAV1 == (initial_pos_UAV1 ->
						if pre_direction_UAV1 == 1 
						then 
							pre_pos_UAV1 + V*deltaT
						else //direction == -1
							pre_pos_UAV1 - V*deltaT)
	
r22 : pos_UAV2 == (initial_pos_UAV2 ->
						if pre_direction_UAV2 == 1 
						then 
							pre_pos_UAV2 + V*deltaT
						else //direction == -1
							pre_pos_UAV2 - V*deltaT)

r23 : pos_UAV3 == (initial_pos_UAV3 ->
						if pre_direction_UAV3 == 1 
						then 
							pre_pos_UAV3 + V*deltaT
						else //direction == -1
							pre_pos_UAV3 - V*deltaT)
 
r31 : goal_UAV1 == if meet_neighbor_12
						then if pos_UAV1 < S_12
								then S_12
								else //pos_UAV1 >= S_12 
									0.0 m
						else if direction_UAV1 == 1
								then P_global
								else //direction_UAV1 == -1 
									0.0 m 

r32 : goal_UAV2 == if meet_neighbor_12
						then S_12
						else if meet_neighbor_23
								then S_23
								else if direction_UAV2 == 1
									then P_global
									else //direction_UAV2 == -1 
										0.0 m 
							
r33 : goal_UAV3 == if meet_neighbor_23
						then if pos_UAV3 > S_23
								then S_23
								else //pos_UAV3 <= S_23 
									P_global
						else if direction_UAV3 == 1
								then P_global
								else //direction_UAV3 == -1 
									0.0 m 

Properties:
Theorem_Alg_A_Three_Vehicles : time >= 2.0*Time_to_travel_full_length implies
					((((pos_UAV1 == 0.0 m and pos_UAV2 == S_23 and pos_UAV3 == S_23)
							and (pre_pos_UAV1 == S_12 and pre_pos_UAV2 == S_12 and pre_pos_UAV3 == P_global))
						or ((pos_UAV1 == S_12 and pos_UAV2 == S_12 and pos_UAV3 == P_global)
							and (pre_pos_UAV1 == 0.0 m and pre_pos_UAV2 == S_23 and pre_pos_UAV3 == S_23)
						))
					and 
						(deltaT == Time_to_travel_full_length/real(N))
					)	