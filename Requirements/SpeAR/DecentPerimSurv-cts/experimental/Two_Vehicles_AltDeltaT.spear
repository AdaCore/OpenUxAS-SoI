Specification Two_Vehicles_AltDeltaT

Imports:
import "../DecentPerimSurvDefs.spear"

Constants:
N : int = 2 //number of vehicles in this case

Inputs:
initial_pos_UAV1 : positionT
initial_direction_UAV1 : signT
initial_pos_UAV2 : positionT
initial_direction_UAV2 : signT

Outputs:
pos_UAV1 : positionT 
pos_UAV2 : positionT 

State:
direction_UAV1 : signT
direction_UAV2 : signT
time : timeT

Macros:
S_1_R : positionT = real(floor(real(1) - 0.5*real(sign(1))))*P_global/real(N)  
//S_1_L : positionT = real(floor(real(1) + 0.5*real(sign(1))))*P_global/real(N) // not used in this version
S_2_L : positionT = real(floor(real(2) - 0.5*real(sign(2))))*P_global/real(N) 
//S_2_R : positionT = real(floor(real(2) + 0.5*real(sign(2))))*P_global/real(N) // not used in this version

pre_pos_UAV1 : positionT = previous pos_UAV1 with initial value initial_pos_UAV1
pre_pos_UAV2 : positionT = previous pos_UAV2 with initial value initial_pos_UAV2
pre_direction_UAV1 : signT = previous direction_UAV1 with initial value initial_direction_UAV1
pre_direction_UAV2 : signT = previous direction_UAV2 with initial value initial_direction_UAV2

time_to_reach_neighbor : timeT = time_to_reach_neighbor(pre_direction_UAV1,
															pre_direction_UAV2,
															pre_pos_UAV1,
															pre_pos_UAV2
															)
time_until_UAV1_reaches_endpoint : timeT = time_to_reach_endpoint(pre_direction_UAV1, pre_pos_UAV1)

time_until_UAV2_reaches_endpoint : timeT = time_to_reach_endpoint(pre_direction_UAV2, pre_pos_UAV2)

time_until_UAV1_reaches_shared_border : timeT = time_to_reach_target_position(pre_direction_UAV1, pre_pos_UAV1, S_1_R)

time_until_UAV2_reaches_shared_border : timeT = time_to_reach_target_position(pre_direction_UAV2, pre_pos_UAV2, S_2_L)

//deltaT : timeT = if met_neighbor 
//					then min_time(time_until_UAV1_reaches_endpoint,
//							min_time(time_until_UAV2_reaches_endpoint,
//									min_time(time_until_UAV1_reaches_shared_border,
//										time_until_UAV2_reaches_shared_border)))
//					else //have yet to meet neighbor, no need to to check shared border yet
//						min_time(time_until_UAV1_reaches_endpoint,
//							min_time(time_until_UAV2_reaches_endpoint,
//										time_to_reach_neighbor))

//Alternate, simpler, definition (but has more checks before meeting neighbors)
deltaT : timeT = min_time(time_until_UAV1_reaches_endpoint,
							min_time(time_until_UAV2_reaches_endpoint,
									min_time(time_until_UAV1_reaches_shared_border,
										min_time(time_until_UAV2_reaches_shared_border,
											time_to_reach_neighbor))))

meet_neighbor : bool = (pos_UAV1 == pos_UAV2) and (previous (pos_UAV1 <> pos_UAV2) with initial value true)
//Assumes only one neighbor exists. 
met_neighbor : bool = false -> if previous meet_neighbor then true else previous met_neighbor

Assumptions:
a0 : initial_pos_UAV1 <= initial_pos_UAV2 //Assume UAV1 is the left UAV and UAV2 is the right UAV.
a1 : true -> initial_pos_UAV1 == previous initial_pos_UAV1
a2 : true -> initial_direction_UAV1 == previous initial_direction_UAV1
a3 : true -> initial_pos_UAV2 == previous initial_pos_UAV2
a4 : true -> initial_direction_UAV2 == previous initial_direction_UAV2

Requirements:
//The next time is the previous time plus the minimum time until a decision/change is made.
// In the case of the solo vehicle, that is reaching an endpoint of the perimeter.
r0 : time == (0.0 s -> previous time + deltaT)

r1 : direction_UAV1 == 
					if meet_neighbor and pos_UAV1 < S_1_R
						then 1
						else if (meet_neighbor or met_neighbor) and pos_UAV1 >= S_1_R
								then -1
								else if pos_UAV1 <= 0.0 m
										then 1
										else if pos_UAV1 >= P_global
												then -1
												else pre_direction_UAV1

r2 : pos_UAV1 == (initial_pos_UAV1 ->
						if pre_direction_UAV1 == 1 
						then 
							pre_pos_UAV1 + V*deltaT
						else //direction == -1
							pre_pos_UAV1 - V*deltaT)

r3 : direction_UAV2 == 
					if meet_neighbor and pos_UAV2 > S_2_L
						then -1
						else if (meet_neighbor or met_neighbor) and pos_UAV2 <= S_2_L
								then 1
								else if pos_UAV2 <= 0.0 m
										then 1
										else if pos_UAV2 >= P_global
												then -1
												else pre_direction_UAV2
	
r4 : pos_UAV2 == (initial_pos_UAV2 ->
						if pre_direction_UAV2 == 1 
						then 
							pre_pos_UAV2 + V*deltaT
						else //direction == -1
							pre_pos_UAV2 - V*deltaT)
 
Properties:
o1_travelling_toward_eo observe : initial_direction_UAV1 == 1 
				and initial_direction_UAV2 == -1
				and initial_pos_UAV1 == 3.1 m
				and initial_pos_UAV2 == 8.4 m
				and time > 20.0 s

o2_travelling_toward_0 observe : initial_direction_UAV1 == -1 
				and initial_direction_UAV2 == -1
				and initial_pos_UAV1 == 3.1 m
				and initial_pos_UAV2 == 8.4 m
				and time > 20.0 s

o3_travelling_away_from_eo observe : initial_direction_UAV1 == -1 
				and initial_direction_UAV2 == 1
				and initial_pos_UAV1 == 3.1 m
				and initial_pos_UAV2 == 8.4 m
				and time > 20.0 s

//Note, the value of the counter on Step 1 is 0.
o4_still_converging_at_6_steps observe: counter == 5 and 
	not	((pos_UAV1 == 0.0 m and pos_UAV2 == P_global)
						or (pos_UAV1 == S_1_R and pos_UAV2 == S_2_L)) 

o5_start_in_same_location observe : initial_pos_UAV1 == initial_pos_UAV1 and time > 20.0 s 

o6_start_at_shared_border_position observe : initial_pos_UAV1 == initial_pos_UAV1 
	and initial_pos_UAV1 == S_1_R
	and initial_direction_UAV1 == 1
	and time > 20.0 s

p_shared_border_calc_matches : S_1_R == S_2_L

p_lemma_stay_stable : true -> previous ((pos_UAV1 == 0.0 m and pos_UAV2 == P_global)
						or (pos_UAV1 == S_1_R and pos_UAV2 == S_2_L)
					) 
					implies ((pos_UAV1 == 0.0 m and pos_UAV2 == P_global)
						or (pos_UAV1 == S_1_R and pos_UAV2 == S_2_L)
					)

p_lemma_get_stable_in_7_steps: counter == 6 implies ((pos_UAV1 == 0.0 m and pos_UAV2 == P_global)
						or (pos_UAV1 == S_1_R and pos_UAV2 == S_2_L))

p_lemma_stable_after_7_steps: counter > 6 implies 
					((pos_UAV1 == 0.0 m and pos_UAV2 == P_global)
						or (pos_UAV1 == S_1_R and pos_UAV2 == S_2_L)
					)

//Though it indeed takes 7 steps to guarantee convergence, traces that converge quickly
// may have more than 2*T elapse by the time they get to 7 steps. Not sure how to make this
// work with the alternate definition of deltaT without doing a case split of some kind.
// It is probably best to stick with the more complex but precise version of deltaT that 
// is only updated when something truly interesting occurs.

//Update: The main theorem still proves, so we don't actually need this lemma. The model checker
// is probably doing the case split for us. Nice!

//p_lemma_7_steps_leq_2T : counter == 6 implies time <= 2.0*Time_to_travel_full_length

		
Theorem_Alg_A_Two_Vehicles : time > 2.0*Time_to_travel_full_length implies
					((pos_UAV1 == 0.0 m and pos_UAV2 == P_global)
						or (pos_UAV1 == S_1_R and pos_UAV2 == S_2_L)
					)
					
					 
