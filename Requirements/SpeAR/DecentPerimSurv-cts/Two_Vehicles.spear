Specification Two_Vehicles

Imports:
import "DecentPerimSurvDefs.spear"

Constants:
N : int = 2 //number of vehicles in this case

Inputs:
initial_pos_UAV1 : positionT
initial_direction_UAV1 : signT
initial_pos_UAV2 : positionT
initial_direction_UAV2 : signT

Outputs:
pos_UAV1 : positionT 
pos_UAV2 : positionT 

State:
direction_UAV1 : signT
direction_UAV2 : signT

time : timeT

goal_UAV1 : positionT
goal_UAV2 : positionT

Macros:
//Shared border positions
S_12 : positionT = 1.0*P_global/real(N)  

//Previous positions
pre_pos_UAV1 : positionT = previous pos_UAV1 with initial value initial_pos_UAV1
pre_pos_UAV2 : positionT = previous pos_UAV2 with initial value initial_pos_UAV2

//Previous directions
pre_direction_UAV1 : signT = previous direction_UAV1 with initial value initial_direction_UAV1
pre_direction_UAV2 : signT = previous direction_UAV2 with initial value initial_direction_UAV2

//Previous goals
pre_goal_UAV1 : positionT = previous goal_UAV1 with initial value (if direction_UAV1 == 1 then P_global else 0.0 m)
pre_goal_UAV2 : positionT = previous goal_UAV2 with initial value (if direction_UAV2 == 1 then P_global else 0.0 m)

//Times to reach neighbors	
time_to_reach_neighbor_12 : timeT = time_to_reach_neighbor(pre_direction_UAV1,
															pre_direction_UAV2,
															pre_pos_UAV1,
															pre_pos_UAV2
															)

//Times to reach goals
time_until_UAV1_reaches_goal : timeT = time_to_reach_target_position(pre_direction_UAV1, pre_pos_UAV1, pre_goal_UAV1)
time_until_UAV2_reaches_goal : timeT = time_to_reach_target_position(pre_direction_UAV2, pre_pos_UAV2, pre_goal_UAV2)

deltaT : timeT = min_time(time_until_UAV1_reaches_goal,
						min_time(time_until_UAV2_reaches_goal,
							time_to_reach_neighbor_12))

//These Booleans are true iff the neighbors meet (i.e., are co-located) on this timestep.
meet_neighbor_12 : bool = (pos_UAV1 == pos_UAV2)

Assumptions:
//Assume UAVs are numbered according to position (by definition)
a0 : initial_value_true(initial_pos_UAV1 <= initial_pos_UAV2) 

Requirements:
//The next time is the previous time plus the minimum time until a decision/change is made.
r0 : time == (0.0 s -> previous time + deltaT)

r11 : direction_UAV1 == if meet_neighbor_12
						then if pos_UAV1 < S_12
								then 1
								else //pos_UAV1 >= S_12 
									-1
						else if pos_UAV1 <= 0.0 m
								then 1
								else pre_direction_UAV1
										
r12 : direction_UAV2 == 
					if meet_neighbor_12 
						then if pos_UAV2 > S_12
								then -1
							else // pos_UAV2 <= S_12
								1
					else if pos_UAV2 >= P_global
							then -1
					else pre_direction_UAV2

r21 : pos_UAV1 == (initial_pos_UAV1 ->
						if pre_direction_UAV1 == 1 
						then 
							pre_pos_UAV1 + V*deltaT
						else //direction == -1
							pre_pos_UAV1 - V*deltaT)

	
r22 : pos_UAV2 == (initial_pos_UAV2 ->
						if pre_direction_UAV2 == 1 
						then 
							pre_pos_UAV2 + V*deltaT
						else //direction == -1
							pre_pos_UAV2 - V*deltaT)

r31 : goal_UAV1 == if meet_neighbor_12
						then if pos_UAV1 < S_12
								then S_12
								else //pos_UAV1 >= S_12 
									0.0 m
						else if direction_UAV1 == 1
								then P_global
								else //direction_UAV1 == -1 
									0.0 m 

r32 : goal_UAV2 == if meet_neighbor_12
						then if pos_UAV2 < S_12
								then P_global 
								else //pos_UAV2 >= S_12
									S_12
						else if direction_UAV2 == 1
								then P_global
								else //direction_UAV2 == -1
									0.0 m
 
Properties:
o1_travelling_toward_eo observe : initial_value_true(direction_UAV1 == 1) 
				and initial_value_true(direction_UAV2 == -1)
				and initial_value_true(pos_UAV1 == 3.1 m)
				and initial_value_true(pos_UAV2 == 8.4 m)
				and time > 20.0 s

o2_travelling_toward_0 observe : initial_value_true(direction_UAV1 == -1) 
				and initial_value_true(direction_UAV2 == -1)
				and initial_value_true(pos_UAV1 == 3.1 m)
				and initial_value_true(pos_UAV2 == 8.4 m)
				and time > 20.0 s

o3_travelling_away_from_eo observe : initial_direction_UAV1 == -1 
				and initial_value_true(direction_UAV2 == 1)
				and initial_value_true(pos_UAV1 == 3.1 m)
				and initial_value_true(pos_UAV2 == 8.4 m)
				and time > 20.0 s

//Note, the value of the counter on Step 1 is 0.
o4_still_converging_at_4_steps observe: counter == 3 and 
	not	((pos_UAV1 == 0.0 m and pos_UAV2 == P_global)
						or (pos_UAV1 == S_12 and pos_UAV2 == S_12)) 

o_still_converging_at_less_than_1pt5T observe: 
	time > 0.9*Time_to_travel_full_length and
	time < 1.5*Time_to_travel_full_length
	and not	((pos_UAV1 == 0.0 m and pos_UAV2 == P_global)
						or (pos_UAV1 == S_12 and pos_UAV2 == S_12)) 


//Be careful in reading this theorem. It means we have convergence on the previous timestep,
// but we don't know exactly what that time was. The time on the previous timestep could 
// have been as large as (2 - 1/N)T - epsilon
Theorem_Alg_A_Two_Vehicles : time >= (2.0 - 1.0/real(N))*Time_to_travel_full_length implies
					((((pos_UAV1 == 0.0 m and pos_UAV2 == P_global)
							and (pre_pos_UAV1 == S_12 and pre_pos_UAV2 == S_12))
						or ((pos_UAV1 == S_12 and pos_UAV2 == S_12)
							and (pre_pos_UAV1 == 0.0 m and pre_pos_UAV2 == P_global)
						))
					and 
						(deltaT == Time_to_travel_full_length/real(N))
					)			
					 
o_slow_to_converge observe: time <2.0*Time_to_travel_full_length
		and (((pos_UAV1 == 0.0 m and pos_UAV2 == P_global)
						and (pre_pos_UAV1 == S_12 and pre_pos_UAV2 == S_12))
					or ((pos_UAV1 == S_12 and pos_UAV2 == S_12)
						and (pre_pos_UAV1 == 0.0 m and pre_pos_UAV2 == P_global)
					))
		and initial_value_true(direction_UAV2 == 1)
		and initial_value_true(direction_UAV1 == 1)
		and initial_value_true(pos_UAV1 == 0.0 m)
		and initial_value_true(pos_UAV2 == 0.01 m)
					 