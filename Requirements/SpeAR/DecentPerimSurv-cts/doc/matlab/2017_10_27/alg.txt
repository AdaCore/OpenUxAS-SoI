Assumptions:
  1. All agents have knowledge of their direction relative to the endpoints of the line 
  2. There is global agreement about the ordering of the endpoints of the line
  3. Agents have knowledge of their position along the line relative to one endpoint
    a. Agent ordering is unambiguous
    b. By convention, a negative velocity indicates travel toward left-most endpoint
    c. By convention, a positive velocity indicates travel toward right-most endpoint
  4. All agents travel at the same constant speed V
  5. Agents can instantaneously change direction
  6. Agents never fail to detect another agent or an end of the line

Memory:
  PR_i := perimeter length to the right of agent i \in [0 .. P]
  PL_i := perimeter length to the left of agent i \in [0 .. P]
  NR_i := number of teammates to the right of agent i \in {0 .. N-1}
  NL_i := number of teammates to the left of agent i \in {0 .. N-1}
  TR_i := ID of neighbor to the immediate right \in {null, 1 .. N}
  TL_i := ID of neighbor to the immediate left \in {null, 1 .. N}
  CR_i := immediate right neighbor also has a right neighbor \in {true, false}
  CL_i := immediate left neighbor also has a left neighbor \in {true, false}

State:
  V_i  := velocity of agent i \in {-V, V}
  x_i  := distance from estimated left-most endpoint along line


  
Algorithm:

Init:
  V_i  := arbitrary \in {-V, V}
  x_i  := arbitrary \in [0 .. P]

  PR_i := 0
  PL_i := 0
  NR_i := 0
  NL_i := 0
  TR_i := null
  TL_i := null
  CR_i := false
  CL_i := false
  p_i  := null


if agent i received update message from neighbor j and traveling together (x_i == x_j)
   Message contents: PR_j, PL_j, NR_j, NL_j, TR_j, TL_j
   if j is the left neighbor of i (TL_i == j)
      // Update perimeter length and team size
      PL_i = PL_j      // j is on left, use its value of PL
      NL_i = NL_j + 1  // j is on left, use its value of NL (plus one since j is to the left of i)
      if j has a left neighbor (TL_j is not null)
         CL_i = true
      // Pass along update
      Send PR_i, PL_i, NR_i, NL_i, TR_i, TL_i to agent TR_i
   else if j is the right neighbor of i (TR_i == j)
      // Update perimeter length and team size
      PR_i = PR_j      // j is on right, use its value of PR
      NR_i = NR_j + 1  // j is on right, use its value of NR (plus one since j is to the right of i)
      if j has a right neighbor (TR_j is not null)
         CR_i = true
      // Pass along update
      Send PR_i, PL_i, NR_i, NL_i, TR_i, TL_i to agent TL_i
   Call Goal_Update()
else if TL_i is null and agent i rendezvous with left neighbor j (x_i == x_j)
   TL_i = j
   Communicate to neighbor j: PR_i, NR_i, TR_i
   Receive from j: PL_j, NL_j, TL_j
   // Update perimeter length and team size
   PL_i = PL_j      // j is on left, use its value of PL
   NL_i = NL_j + 1  // j is on left, use its value of NL (plus one since j is to the left of i)
   if j has a left neighbor (TL_j is not null)
      CL_i = true
   // Pass along update
   Send PR_i, PL_i, NR_i, NL_i, TR_i, TL_i to agent TR_i
   Call Goal_Update()
else if TR_i is null and agent i rendezvous with right neighbor j (x_i == x_j)
   TR_i = j
   Communicate to neighbor j: PL_i, NL_i, TL_i
   Receive from j: PR_j, NR_j, TR_j
   // Update perimeter length and team size
   PR_i = PR_j      // j is on right, use its value of PR
   NR_i = NR_j + 1  // j is on right, use its value of NR (plus one since j is to the right of i)
   if j has a right neighbor (TR_j is not null)
      CR_i = true
   // Pass along update
   Send PR_i, PL_i, NR_i, NL_i, TR_i, TL_i to agent TL_i
   Call Goal_Update()
else if TL_i is null and reached left perimeter endpoint then
   Reset perimeter length to the left PL_i = 0
   Reset team size to the left NL_i = 0
   // Pass along update
   Send PR_i, PL_i, NR_i, NL_i, TR_i, TL_i to agent TR_i
   Call Goal_Update()
   Set direction away from endpoint V_i = V
else if TR_i is null and reached right perimeter endpoint then
   Reset perimeter length to the right PR_i = 0
   Reset team size to the right NR_i = 0
   // Pass along update
   Send PR_i, PL_i, NR_i, NL_i, TR_i, TL_i to agent TL_i
   Call Goal_Update()
   Set direction away from endpoint V_i = -V
else if reached goal (x_i == p_i)
   Call Goal_Update()
   
Goal_Update()
   Reset goal to none p_i = null
   Calculate estimated team size N = NR_i + NL_i + 1
   Calculate estimated perimeter length P = PR_i + PL_i
   Calculate relative index n = NL_i + 1.
   // Calculate preferred segment endpoints for neighbors
   yl = (n-2)*P/N
   xl = (n-1)*P/N
   xr = (n+0)*P/N
   yr = (n+1)*P/N

   // Calculate goal locations, min tie breaks to left
   p  = argmin_{x={xl,xr}} ||x_i - x||
   pl = argmin_{x={yl,xl}} ||x_i - x||
   pr = argmin_{x={xr,yr}} ||x_i - x||

   // choose preferred escort location for i
   if TR_i is not null and TL_i is not null
      // both endpoints are valid, choose closest with tie break to left
      p_i = p
   else if TR_i is not null
      p_i = xr
   else if TL_i is not null
      p_i = xl

   // left neighbor committed to travel with i if no other neighbors
   if left neighbor is only neighbors with i (CL_i is false)
      pl = xl

   // right neighbor committed to travel with i if no other neighbors
   if right neighbor is only neighbors with i (CR_i is false)
      pr = xr

   if reached left goal location (p_i not null and p_i == x_i and p_i == xl)
      if there is a neighbor to the left (TL_i not null)
         // successful escort with TL_i, so separate and monitor own segment
         p_i = xr
         TL_i = null
         CL_i = false
         // inform right neighbor that no longer in clique
         Send PR_i, PL_i, NR_i, NL_i, TR_i, TL_i to agent TR_i
   if reached right goal location (p_i not null and p_i == x_i and p_i == xr)
      if there is a neighbor to the right (TR_i not null)
         // successful escort with TR_i, so separate and monitor own segment
         p_i = xl
         TR_i = null
         CR_i = false
         // inform left neighbor that no longer in clique
         Send PR_i, PL_i, NR_i, NL_i, TR_i, TL_i to agent TL_i
   if left neighbor reached a goal (TL_i not null and CL_i is true and x_i == pl)
         // TL_i successfully escorted its left neighbor
         CL_i = false
   if right neighbor reached a goal (TR_i not null and CR_i is true and x_i == pr)
         // TR_i successfully escorted its right neighbor
         CR_i = false

   // set velocity appropriate to reach goal
   if p_i is to the left of x_i
      V_i = -V
   else if p_i is to the right of x_i
      V_i = V

   // predict velocity for left neighbor
   vl = V_i
   if pl is to the left of x_i
      vl = -V
   else if pl is to the right of x_i
      vl = V

   // predict velocity for right neighbor
   vr = V_i
   if pr is to the left of x_i
      vr = -V
   else if pr is to the right of x_i
      vr = V

   if not yet reached goal location (p_i not null and p_i != x_i)
      if not going the same direction as left neighbor ( V_i != vl )
         // no longer traveling with left neighbor
         TL_i = null
         CL_i = false
      if not going the same direction as right neighbor ( V_i != vr )
         // no longer traveling with right neighbor
         TR_i = null
         CR_i = false

   // no intermediate goals without neighbors
   if TL_i is null and TR_i is null
      p_i = null
