Definitions DecentPerimSurvDefs

Units:
s "seconds"
m "meters"
mps : m/s "meters per second"

Types:
timeT: real s
velocityT : real mps
lengthT: real m
signT : {i : int | i == -1 or i == 1 }
nonnegLengthT : {l : lengthT | l >= 0.0 m}
positionT : {l : nonnegLengthT | l <= P_global}

Constants:
V : velocityT = 1.0 mps
P_global : nonnegLengthT = 10.0 m //Total perimeter size -- useful to bound initial positions of vehicles
Time_to_travel_full_length : timeT = P_global/V

Patterns:
	
//Returns the minimum of two timeTs
pattern min_time(a: timeT, b : timeT) returns (out: timeT)
	let
		out = if a <= b then a else b 
	tel

//Computes the time to reach the endpoint that the vehicle is heading toward
// direction of -1 means the vehicle is heading toward 0
// direction of +1 means the vehicle is heading toward P_global
pattern time_to_reach_endpoint(direction: signT, position: positionT) returns (out : timeT)
	let	
		out = if direction == 1 
				then 
					(P_global - position)/V 
				else //direction == -1 
					position/V
	tel

pattern time_to_reach_neighbor( direction_UAV1: signT, 
								direction_UAV2 : signT, 
								position_UAV1: positionT, 
								position_UAV2 : positionT) 
								returns (out : timeT)
	let	
		out = if position_UAV1 == position_UAV2
				then Time_to_travel_full_length //We'll reach an endpoint, shared border, or another neighbor before these two meet NEXT.
				else if position_UAV2 > position_UAV1 
						then if direction_UAV1 == 1 and direction_UAV2 == -1
								then 0.5*(position_UAV2 - position_UAV1)/V
								else Time_to_travel_full_length //we'll reach an endpoint first, so just use the max time to reach an endpoint
						else // position_UAV2 < position_UAV1 
							if direction_UAV1 == -1 and direction_UAV2 == 1
								then 0.5*(position_UAV1 - position_UAV2)/V
								else Time_to_travel_full_length //we'll reach an endpoint first, so just use the max time to reach an endpoint 
		
	tel	
	
pattern time_to_reach_target_position(direction: signT, 
								UAV_pos: positionT, 
								target_pos : positionT
								) returns (out : timeT)
	let	
		out = if target_pos > UAV_pos and direction == 1 
				then 
					(target_pos - UAV_pos)/V 
				else if target_pos < UAV_pos and direction == -1
						then 
							(UAV_pos - target_pos)/V
						else //we're traveling away from the target position
							Time_to_travel_full_length //we'll reach an endpoint or another neighbor first, so just use the max time to reach an endpoint
				
	tel

pattern initial_value_true(a : bool) returns (holds : bool)
	var
	  pre_state : int
	  state : int
	let
	  pre_state = previous state with initial value 0
	
	  state = 
	  if (pre_state == 0) 
	  then 
	    if a 
	    then 1 
	    else 2
	  else pre_state

	  holds = ((state == 0) or (state == 1))
	
	tel

//I don't think this is used anymore.	
pattern sign(i: int) returns (output : signT)
	let
		output = if i mod 2 == 0 then 1 else -1
	tel

	