Specification Three_Vehicles

Imports:
import "../DecentPerimSurvDefs.spear"
import "UAV.spear"

Constants:
N : int = 3 //number of vehicles in this case

Inputs:
initial_pos_UAV1 : positionT
suggested_initial_direction_UAV1 : signT
initial_pos_UAV2 : positionT
suggested_initial_direction_UAV2 : signT
initial_pos_UAV3 : positionT
suggested_initial_direction_UAV3 : signT

Outputs:
pos_UAV1 : positionT 
pos_UAV2 : positionT
pos_UAV3 : positionT  

State:
direction_UAV1 : signT
direction_UAV2 : signT
direction_UAV3 : signT

time : timeT

goal_UAV1 : positionT
goal_UAV2 : positionT
goal_UAV3 : positionT

Macros:
//Shared border positions
S_12 : positionT = real(1)*P_global/real(N)  
S_23 : positionT = real(2)*P_global/real(N)

//Previous positions
pre_pos_UAV1 : positionT = previous pos_UAV1 with initial value initial_pos_UAV1
pre_pos_UAV2 : positionT = previous pos_UAV2 with initial value initial_pos_UAV2
pre_pos_UAV3 : positionT = previous pos_UAV3 with initial value initial_pos_UAV3

//Previous directions
pre_direction_UAV1 : signT = previous direction_UAV1 with initial value suggested_initial_direction_UAV1
pre_direction_UAV2 : signT = previous direction_UAV2 with initial value suggested_initial_direction_UAV2
pre_direction_UAV3 : signT = previous direction_UAV3 with initial value suggested_initial_direction_UAV3

//Previous goals
pre_goal_UAV1 : positionT = previous goal_UAV1 with initial value (if direction_UAV1 == 1 then P_global else 0.0 m)
pre_goal_UAV2 : positionT = previous goal_UAV2 with initial value (if direction_UAV2 == 1 then P_global else 0.0 m)
pre_goal_UAV3 : positionT = previous goal_UAV3 with initial value (if direction_UAV3 == 1 then P_global else 0.0 m)


//Times to reach neighbors													)
time_to_reach_neighbor_12 : timeT = time_to_reach_neighbor(pre_direction_UAV1,
															pre_direction_UAV2,
															pre_pos_UAV1,
															pre_pos_UAV2
															)
															
time_to_reach_neighbor_23 : timeT = time_to_reach_neighbor(pre_direction_UAV2,
															pre_direction_UAV3,
															pre_pos_UAV2,
															pre_pos_UAV3
															)
//Times to reach goals
time_until_UAV1_reaches_goal : timeT = time_to_reach_target_position(pre_direction_UAV1, pre_pos_UAV1, pre_goal_UAV1)
time_until_UAV2_reaches_goal : timeT = time_to_reach_target_position(pre_direction_UAV2, pre_pos_UAV2, pre_goal_UAV2)
time_until_UAV3_reaches_goal : timeT = time_to_reach_target_position(pre_direction_UAV3, pre_pos_UAV3, pre_goal_UAV3)

//These Booleans are true iff the neighbors meet (i.e., are co-located) on this timestep.
meet_neighbor_12 : bool = (pos_UAV1 == pos_UAV2) 
meet_neighbor_23 : bool = (pos_UAV2 == pos_UAV3) 

deltaT : timeT = min_time(time_until_UAV1_reaches_goal,
					min_time(time_until_UAV2_reaches_goal,
						min_time(time_until_UAV3_reaches_goal,
							min_time(time_to_reach_neighbor_12,
								time_to_reach_neighbor_23))))
							

Assumptions:
//Assume UAVs are numbered according to position (by definition)
a00 : initial_value_true(initial_pos_UAV1 <= initial_pos_UAV2)
a01 : initial_value_true(initial_pos_UAV2 <= initial_pos_UAV3)  

Requirements:
//The next time is the previous time plus the minimum time until a decision/change is made.
r0 : time == (0.0 s -> previous time + deltaT)

r11 : |direction_UAV1, goal_UAV1| == 
		spec UAV(suggested_initial_direction_UAV1, 
					false, 
					meet_neighbor_12, 
					1,
					N,
					pos_UAV1)	

r12 : |direction_UAV2, goal_UAV2| == 
		spec UAV(suggested_initial_direction_UAV2, 
					meet_neighbor_12,
					meet_neighbor_23, 
					2,
					N,
					pos_UAV2)	

r13 : |direction_UAV1, goal_UAV1| == 
		spec UAV(suggested_initial_direction_UAV1, 
					meet_neighbor_23, 
					false, 
					1,
					N,
					pos_UAV1)	
						
r21 : pos_UAV1 == (initial_pos_UAV1 ->
						if pre_direction_UAV1 == 1 
						then 
							pre_pos_UAV1 + V*deltaT
						else //direction == -1
							pre_pos_UAV1 - V*deltaT)
	
r22 : pos_UAV2 == (initial_pos_UAV2 ->
						if pre_direction_UAV2 == 1 
						then 
							pre_pos_UAV2 + V*deltaT
						else //direction == -1
							pre_pos_UAV2 - V*deltaT)

r23 : pos_UAV3 == (initial_pos_UAV3 ->
						if pre_direction_UAV3 == 1 
						then 
							pre_pos_UAV3 + V*deltaT
						else //direction == -1
							pre_pos_UAV3 - V*deltaT)

Properties:
Theorem_Alg_A_Three_Vehicles : time >= 1.67*Time_to_travel_full_length implies
					((((pos_UAV1 == 0.0 m and pos_UAV2 == S_23 and pos_UAV3 == S_23)
							and (pre_pos_UAV1 == S_12 and pre_pos_UAV2 == S_12 and pre_pos_UAV3 == P_global))
						or ((pos_UAV1 == S_12 and pos_UAV2 == S_12 and pos_UAV3 == P_global)
							and (pre_pos_UAV1 == 0.0 m and pre_pos_UAV2 == S_23 and pre_pos_UAV3 == S_23)
						))
					and 
						(deltaT == Time_to_travel_full_length/real(N))
					)	