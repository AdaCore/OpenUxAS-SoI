Specification route_aggregator

Imports:
  import "uxas_types.spear"
  
Patterns:
  /*
   * If we had quantification over sets, we'd state this something like this, given
   * 
   *   map : [route_request_message -> {requests: set of route_plan_request_message,
   *                                    responses: set of route_plan_response_message}]
   * 
   * (that is, map is a function):
   * 
   *   all (vehicle_id : route_request.vehicle_ids) :
   *     exists (route_plan_request: map[route_request].requests) :
   *       route_plan_request.vehicle_id == vehicle_id
   * 
   *   and
   * 
   *   all (route_plan_request: map[route_request].requests) :
   *     unique(route_plan_request.id)
   * 
   * where unique is some predicate indicating appropriate uniqueness.
   * 
   * The above handles the notion of insertion into the map as well as simply 
   * generating the set of requests. Below, we focus just on building up the set and
   * assume that all vehicle ids are used. Hiding these details would be good, but I 
   * can't think of a good way to do so.
   * 
   * We could of course have constructed the message set directly, since it's actually
   * an array, but we use the insertion abstraction to hide that detail.
   */
  pattern create_unique_route_plan_requests_for_each_vehicle_id_in(
    msg: route_request_message)
  returns (
    result: route_plan_request_message_set)
  let
    result = insert_route_plan_request(
               insert_route_plan_request(
                 insert_route_plan_request(
                   NULL_ROUTE_PLAN_REQUEST_SET,
                   new route_plan_request_message {
                     id = generate_unique_id(),
                     vehicle_id = msg.vehicle_ids[0]
                   }
                 ),
                 
                 new route_plan_request_message {
                   id = generate_unique_id(),
                   vehicle_id = msg.vehicle_ids[1]
                 }
               ),
               
               new route_plan_request_message {
                 id = generate_unique_id(),
                 vehicle_id = msg.vehicle_ids[2]
               }
             )
  tel

  /*
   * If we had quantification over sets, we'd state this something like this, given
   * 
   *   map : [route_request_message -> {requests: set of route_plan_request_message,
   *                                    responses: set of route_plan_response_message}]
   * 
   * (that is, map is a function):
   * 
   *   exists (route_request: previous map.domain) : 
   *     exists (route_plan_request: previous map[route_request].requests) : 
   *       route_plan_request.id == response.id 
   * 
   *   implies
   * 
   *   exists (route_request: map.domain) : 
   *     exists (route_plan_request: map[route_request].requests) :
   *       exists (route_plan_response: map[route_request].responses :
   *         route_plan_request.id == route_plan_response.id == response.id
   * 
   * Which says that if there's a request with the given response id, then we'll update
   * the map so that it now contains the response. Critically, the above says nothing
   * about the search mechanism nor the update mechanism, but just describes the
   * essential transformation of state.
   * 
   * The below is an attempt to echo this kind of minimal constraint by hiding the
   * details of the getting and the insertion behind a layer of abstraction.
   */
  pattern correlate_route_plan_responses_to_requests(
    map: route_request_map,
    response: route_plan_response_message)
  returns (
    result: route_request_map)
  var
    route_request: route_request_message
  let
    route_request = get_route_request_for_response(map, response)
  
    result = if (route_request <> NULL_ROUTE_REQUEST) then
               insert_route_plan_response_into_map(map, route_request, response)
             else
               map
  tel
    
  
  /*
   * If we had quantification over sets, we'd state this something like this, given
   * 
   *   map : [route_request_message -> {requests: set of route_plan_request_message,
   *                                    responses: set of route_plan_response_message}]
   * 
   * (that is, map is a function):
   * 
   *   let t_route_request : map.domain U NULL_ROUTE_REQUEST in
   *     t_route_request <> NULL_ROUTE_REQUEST implies
   *       all (route_plan_request : map[t_route_request].requests) :
   *         exists (route_plan_response: map[t_route_request].responses :
   *           route_plan_request.id == route_plan_response.id
   *                                                   
   * In other words, t_route_request will either be null or will be an element from 
   * the domain of the map for which every request has a corresponding response.
   * 
   * I can't think of a way to abstract this in useful pieces (without reabstracting
   * the whole pattern)
   * 
   */
  pattern get_complete_route_request(
    map: route_request_map)
  returns (
    result: route_request_message)
  let
    result = if route_plan_responses_full(map.route_plan_response_sets[0]) then
               map.route_requests[0]
             else if route_plan_responses_full(map.route_plan_response_sets[1]) then
               map.route_requests[1]
             else if route_plan_responses_full(map.route_plan_response_sets[2]) then
               map.route_requests[2]
             else
               NULL_ROUTE_REQUEST
  tel

Inputs:
  route_request is a route_request_message

  route_plan_response is a route_plan_response_message

Outputs:
  route_response is a route_response_message

  route_plan_requests is a route_plan_request_message_set
  
State:
  request_map is a route_request_map
  
  t_route_request is a route_request_message
  
  t_route_plan_requests is a route_plan_request_message_set
  
Assumptions:
  /*
   * This exists only because our implementation is limited - there is no associated
   * requirement
   */
  no_overflow:
    request_map_full(previous request_map) implies route_request == NULL_ROUTE_REQUEST

Requirements:
  state_initialize:
    initially zeroed_request_map(previous request_map)

  RA1:
    if route_request <> NULL_ROUTE_REQUEST then
      t_route_plan_requests == 
        create_unique_route_plan_requests_for_each_vehicle_id_in(route_request)

    text = "The configuration shall create a unique RoutePlanRequest message 
            for each vehicle ID in each RouteRequest message received"
    
  RA1_5:
    if route_request <> NULL_ROUTE_REQUEST then
      request_map == insert_route_plan_requests(previous request_map, 
                                                route_request,
                                                t_route_plan_requests)
    
    text = "[MISSING] The configuration shall keep track of the RoutePlanRequest 
            messages associated with each RouteRequest message [until the 
            RouteReponse message is sent?]"
      

  RA2:
    if route_request <> NULL_ROUTE_REQUEST then
      route_plan_requests == get_route_plan_requests(request_map, 
                                                     route_request)
      
    text = "The configuration shall send each RoutePlanRequest message to the 
            planners that are appropriate for the associated vehicle type"

  RA3:
    if route_plan_response <> NULL_ROUTE_PLAN_RESPONSE then
      request_map == correlate_route_plan_responses_to_requests(previous request_map, 
                                                                route_plan_response)
      
    text = "The configuration shall correlate RoutePlanReponses with 
            RoutePlanRequests"

  RA4:
    t_route_request == get_complete_route_request(previous request_map) and
    if t_route_request <> NULL_ROUTE_REQUEST then
      route_response == new route_response_message {
        id = t_route_request.id
      }
    else
      route_response == NULL_ROUTE_RESPONSE
    
    text = "The configuration shall send a RouteResponse message when 
            all RoutePlanResponses are received for a particular RouteRequest"


  cleanup:
    t_route_request == get_complete_route_request(previous request_map) and
    request_map == delete_route_request_from_map(previous request_map, t_route_request)

Properties:
  map_of_one observe: request_map.route_requests[0] <> NULL_ROUTE_REQUEST
  
  map_of_two observe: request_map.route_requests[1] <> NULL_ROUTE_REQUEST
  
  map_of_three observe: request_map.route_requests[2] <> NULL_ROUTE_REQUEST
  prev_map_of_three observe: (previous request_map).route_requests[2] <> NULL_ROUTE_REQUEST
  
  full_map observe: request_map_full(request_map)
  prev_full_map observe: request_map_full(previous request_map)
