aggregator : THEORY

BEGIN
  % Rebuild the member predicate so that we can curry the element being checked
  % for membership
  member?[T: TYPE](s: set[T]): pred[T] =
    LAMBDA(x: T):
      member(x, s);


  % Represent the set of vehicle IDs that have been defined in our system.
  defined_vehicle_ids: VAR set[nat];
 

  defined_vehicle_id?( v: nat ): bool = member(v, defined_vehicle_ids);

  % A vehicle ID that is drawn from the set of defined vehicle IDs.
  valid_vehicle_id: TYPE = ( defined_vehicle_id? );

  % A set of valid vehicle IDs.
  valid_vehicle_id_set: TYPE = set[valid_vehicle_id];

  
  % Represent a Route Request message.
  route_request_message: NONEMPTY_TYPE = 
    [# id: nat,
       vehicle_ids: valid_vehicle_id_set #]
  CONTAINING
    (# id := 0,
       vehicle_ids := emptyset #);

  default_route_request: route_request_message =
    (# id := 0,
       vehicle_ids := emptyset #);

  % A set of Route Request messages
  route_request_message_set: TYPE = set[route_request_message];


  % Represent a Route Plan Request message.
  route_plan_request_message: NONEMPTY_TYPE =
    [# id: nat,
       vehicle_id: valid_vehicle_id #]
  CONTAINING
    (# id := 0,
       vehicle_id := 0 #);

  default_route_plan_request: route_plan_request_message = 
    (# id := 0,
       vehicle_id := 0 #);

  % As set of Route Plan Requests
  route_plan_request_message_set: TYPE = set[route_plan_request_message];


  % Represent a Route Plan Response message.
  route_plan_response_message: NONEMPTY_TYPE =
    [# id: nat,
       addressing: nat #]
  CONTAINING
    (# id := 0,
       addressing := 0 #);

  default_route_plan_response: route_plan_response_message =
    (# id := 0,
       addressing := 0 #);


  % This function relates sets of Route Plan Requests to Route Requests. Using
  % this function, given a Route Request, the set of associated Route Plan 
  % Requests can be 
  route_request_to_set_of_route_plan_requests(route_requests: route_request_message_set): TYPE = [ ( member?(route_requests) ) -> route_plan_request_message_set ]

  unique_id_within_set?( route_requests: route_request_message_set, 
  			 map: route_request_to_set_of_route_plan_requests(route_requests) ) : bool =
    FORALL ( rr : ( member?(route_requests) ),
    	     rpr1: ( member?(map(rr)) ),
	     rpr2: { r: ( member?(map(rr)) ) | r /= rpr1 } ):
      rpr1`id /= rpr2`id;

  unique_id_amongst_sets?( route_requests: route_request_message_set,
			   map: route_request_to_set_of_route_plan_requests(route_requests) ) : bool = 
    FORALL ( rr1: ( member?(route_requests) ),
             rr2: {r : ( member?(route_requests) ) | r /= rr1 } ),
             rpr1: ( member?(map(rr1)) ),
	     rpr2: ( member?(map(rr2)) ):
      rpr1`id /= rpr2`id;

  unique_id?( route_requests: route_request_message_set,
  	      map: route_request_to_set_of_route_plan_requests(route_requests) ) : bool = 
    unique_id_within_set?(route_requests, map) AND unique_id_amongst_sets?(route_requests, map);

  unique_route_request_to_set_of_route_plan_requests?( rrs: route_request_message_set ) : pred[route_request_to_set_of_route_plan_requests(route_requests)] =
    LAMBDA( m: [ ( member?(route_requests) ) -> route_plan_request_message_set ] ):
      unique_id?(rrs, m);

  route_request_to_unique_set_of_route_plan_requests(route_requests: route_request_message_set): TYPE = ( unique_route_request_to_set_of_route_plan_requests?(route_requests) )

  % RA1: The configuration shall create a unique RoutePlanRequest message for each 
  % vehicle ID in each RouteRequest message received  
  generate( route_requests : route_request_message_set,
  	    route_plan_requests : route_request_to_set_of_unique_route_plan_requests(route_requests),
	    route_request : route_request_message ) : [ rs: route_request_message_set,
	    		    			        [ route_request_to_set_of_unique_route_plan_requests(rs) ] ] =
    LET new_route_requests: ( member?(route_request_message_set) ) = LAMBDA ( rr: route_request_message ):
                                                                              member(rr, route_requests) OR rr = route_request
    IN						  
    (
      new_route_requests,

      LAMBDA ( rr: ( member?(new_route_requests) ) ):
        IF member(rr, route_requests) THEN
	  route_plan_requests(rr)
        ELSE
	  create( rr`vehicle_ids, route_plan_requests )
	ENDIF
    );
  

  all_vehicle_ids?( vehicle_ids: valid_vehicle_id_set,
  		    route_plan_requests: route_plan_request_message_set ): bool = 
    FORALL ( v : vehicle_ids ): EXISTS ( rpr: route_plan_requests ): v = rpr`vehicle_id;

  only_vehicle_ids?( vehicle_ids: valid_vehicle_id_set,
  		     route_plan_requests: route_plan_request_message_set ): bool =
    FORALL ( rpr: s ): EXISTS ( v : vehicle_ids ): v = rpr`vehicle_id;

  all_and_only_vehicle_ids?( vehicle_ids: valid_vehicle_id_set ): pred[route_plan_request_message_set] = 
    LAMBDA ( s: route_plan_request_message_set ):
      all_vehicle_ids?(vehicle_ids, s) AND only_vehicle_ids?(vehicle_ids, s)


  create( vehicle_ids: valid_vehicle_id_set, 
  	  route_requests: route_request_message_set, 
	  route_plan_requests: route_request_to_unique_set_of_route_plan_requests(route_requests) ): ( all_and_only_vehicle_ids?(vehicle_ids) )

{ s: set[{ rpr: route_plan_request_message | EXISTS ( v: vehicle_ids ): v = rpr`vehicle_id }] | FORALL ( v : vehicle_ids) EXISTS ( rpr: s ): v = rpr`vehicle_ID } AND 
  
  unique?(id: nat): bool
	    
  % RA4: The configuration shall correlate RoutePlanReponses with RoutePlanRequests
  correlate( route_requests : route_request_message_set,
  	     route_plan_requests : [ ( route_request_member?(route_requests) ) -> route_plan_request_message_set ],
	     route_plan_responses : [ rr: { rrm: route_request_message | member(rr, route_requests) },
	     			      { rpr: route_plan_request_message | member(rpr, route_plan_requests(rr)) } -> route_plan_response_message ],
	     route_plan_response : route_plan_response_message ): 
	       [ rr: { rrm: route_request_message | member(rr, route_requests) },		
                 { rpr: route_plan_request_message | member(rpr, route_plan_requests(rr)) } -> route_plan_response_message ] =
    LAMBDA ( rr: { rrm: route_request_message | member(rr, route_requests) },
             { rpr: route_plan_request_message | member(rpr, route_plan_requests(rr)) } ):
      IF ( rpr.id = route_plan_response.id ) THEN
      	route_plan_response
      ELSE
	route_plan_responses(rr, rpr)
      ENDIF

END aggregator
