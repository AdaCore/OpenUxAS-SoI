package UAV_Pkg
public
	--with DPSS_Data_Types;
	with Base_Types;
	with DPSS_Constants;
	 
	system UAV
		features
			--Inputs
			suggested_initial_direction : in data port Base_Types::Integer; --The UAV may choose a different direction for the initial timestep, depending on the circumstances.
			initial_position : in data port Base_Types::Float;
			pos_LN : in data port Base_Types::Float; --Position of left neighbor (< 0  if there is no left neighbor)
			pos_RN : in data port Base_Types::Float; --Position of right neighbor (> P_GLOBAL if there is no right neighbor)
			id : in data port Base_Types::Integer; --a positive integer between 1 and N
			
			--Outputs
			direction: out data port Base_Types::Integer;
			goal : out data port Base_Types::Float;
			pos : out data port Base_Types::Float;
					
		annex agree {**
			
			-----------------------------------------------------
			--STATE VARIABLES
			-----------------------------------------------------		
				
			--Shared border positions
			eq S_L : real = real(id-1)*DPSS_Constants.P_GLOBAL/DPSS_Constants.N_real;  
			eq S_R : real = real(id)*DPSS_Constants.P_GLOBAL/DPSS_Constants.N_real;	
				
			--Previous direction
			eq pre_direction : int = 
				prev(direction, suggested_initial_direction);
				
			--Previous position
			eq pre_pos : real =
				prev(pos, initial_position);
			
			--These Booleans are true iff the neighbors meet (i.e., are co-located) on this timestep. 
			eq meet_LN : bool = (pos_LN = pos); --Meet left neighbor?
			eq meet_RN : bool = (pos_RN = pos); --Meet right neighbor?
			
		--	eq deltaT : real = 0.0 -> time - pre(time);
					
			-----------------------------------------------------
			--ASSUMPTIONS
			-----------------------------------------------------		
			
			assume "ID in range":
				id >= 1 and id <= DPSS_Constants.N_int;
						
			assume "ID is fixed":
				true -> (id = pre(id));
			
			assume "Input initial position is between 0 and P_GLOBAL":
				(	0.0 <= initial_position
				and initial_position <= DPSS_Constants.P_GLOBAL)
				-> true;
							
			assume "Suggested initial direction is LEFT or RIGHT":
				(		suggested_initial_direction = DPSS_Constants.LEFT
					or 	suggested_initial_direction = DPSS_Constants.RIGHT)
				-> true;
			
			assume "ID = 1 implies pos_LN < 0":
				id = 1 => pos_LN < 0.0;
				
			assume "ID = N implies pos_RN > P_GLOBAL":
				id = DPSS_Constants.N_int => pos_RN > DPSS_Constants.P_GLOBAL;
						
			-----------------------------------------------------
			--GUARANTEES
			-----------------------------------------------------		

			guarantee "Direction formula":
				direction = (
					if pos <= 0.0 then
						1
					else 
						if pos >= DPSS_Constants.P_GLOBAL then
							-1
						else 
							if meet_LN then
								if pos <= S_L then
									1
								else --pos > S_L
									-1
							else
							  	if meet_RN then
									if pos < S_R then
										1
									else --pos >= S_R
										-1 
								else 
									pre_direction
				);  

			guarantee "Goal formula":
				goal = (
						if meet_LN and meet_RN then
							if pos <= S_L then
								S_R
							else -- pos > S_L
								S_L 
						else		
							if meet_LN then
								if pos <= S_L then
									DPSS_Constants.P_GLOBAL
								else -- pos > S_L
									S_L
							else 
								if meet_RN then
									if pos >= S_R then
										0.0
									else -- pos < S_R
										S_R
								else 
									if direction = 1 then
										DPSS_Constants.P_GLOBAL
									else --direction = -1 
										0.0 
				); 

			guarantee "Position formula":
				pos = (initial_position -> 
						(if pre_direction = 1 then
							pre_pos + DPSS_Constants.V*(time - pre(time))
						else --pre_direction = -1
							pre_pos - DPSS_Constants.V*(time - pre(time))));
			
		**};
		
	end UAV;
end UAV_Pkg;