package DPSS_6_Vehicles_Pkg
public
	with DPSS_Data_Types;
	with DPSS_Node_Lib;
	with DPSS_Constants;
	with UAV_Pkg;
	
	system DPSS_6_Vehicles
		features
			-----------------------------------------------------
			--INPUTS
			-----------------------------------------------------
			
			--Initial positions
			initial_pos_UAV1 : in data port DPSS_Data_Types::Position_Type;
			initial_pos_UAV2 : in data port DPSS_Data_Types::Position_Type;
			initial_pos_UAV3 : in data port DPSS_Data_Types::Position_Type;			
			initial_pos_UAV4 : in data port DPSS_Data_Types::Position_Type;			
			initial_pos_UAV5 : in data port DPSS_Data_Types::Position_Type;
			initial_pos_UAV6 : in data port DPSS_Data_Types::Position_Type;
			
			--Suggested initial directions			
			suggested_initial_direction_UAV1 : in data port DPSS_Data_Types::Direction_Type;
			suggested_initial_direction_UAV2 : in data port DPSS_Data_Types::Direction_Type;
			suggested_initial_direction_UAV3 : in data port DPSS_Data_Types::Direction_Type;
			suggested_initial_direction_UAV4 : in data port DPSS_Data_Types::Direction_Type;
			suggested_initial_direction_UAV5 : in data port DPSS_Data_Types::Direction_Type;
			suggested_initial_direction_UAV6 : in data port DPSS_Data_Types::Direction_Type;
			
			-----------------------------------------------------
			--OUTPUTS
			-----------------------------------------------------

			--Vehicle positions
			pos_UAV1 : out data port DPSS_Data_Types::Position_Type;
			pos_UAV2 : out data port DPSS_Data_Types::Position_Type;
			pos_UAV3 : out data port DPSS_Data_Types::Position_Type;
			pos_UAV4 : out data port DPSS_Data_Types::Position_Type;
			pos_UAV5 : out data port DPSS_Data_Types::Position_Type;
			pos_UAV6 : out data port DPSS_Data_Types::Position_Type;
			 
		annex agree {**
			
			--Directions
			eq direction_UAV1 : DPSS_Data_Types::Direction_Type;
			eq direction_UAV2 : DPSS_Data_Types::Direction_Type;
			eq direction_UAV3 : DPSS_Data_Types::Direction_Type;
			eq direction_UAV4 : DPSS_Data_Types::Direction_Type;
			eq direction_UAV5 : DPSS_Data_Types::Direction_Type;
			eq direction_UAV6 : DPSS_Data_Types::Direction_Type;
	
			--Goals
			eq goal_UAV1 : DPSS_Data_Types::Position_Type;
			eq goal_UAV2 : DPSS_Data_Types::Position_Type;
			eq goal_UAV3 : DPSS_Data_Types::Position_Type;
			eq goal_UAV4 : DPSS_Data_Types::Position_Type;
			eq goal_UAV5 : DPSS_Data_Types::Position_Type;
			eq goal_UAV6 : DPSS_Data_Types::Position_Type;
			
			--Shared border positions
			eq S_12 : DPSS_Data_Types::Position_Type = 1.0*DPSS_Constants.P_GLOBAL/DPSS_Constants.N_real;  
			eq S_23 : DPSS_Data_Types::Position_Type = 2.0*DPSS_Constants.P_GLOBAL/DPSS_Constants.N_real;
			eq S_34 : DPSS_Data_Types::Position_Type = 3.0*DPSS_Constants.P_GLOBAL/DPSS_Constants.N_real;
			eq S_45 : DPSS_Data_Types::Position_Type = 4.0*DPSS_Constants.P_GLOBAL/DPSS_Constants.N_real;
			eq S_56 : DPSS_Data_Types::Position_Type = 5.0*DPSS_Constants.P_GLOBAL/DPSS_Constants.N_real;
			
			--Previous positions
			eq pre_pos_UAV1 : DPSS_Data_Types::Position_Type = prev(pos_UAV1, initial_pos_UAV1);
			eq pre_pos_UAV2 : DPSS_Data_Types::Position_Type = prev(pos_UAV2, initial_pos_UAV2);
			eq pre_pos_UAV3 : DPSS_Data_Types::Position_Type = prev(pos_UAV3, initial_pos_UAV3);
			eq pre_pos_UAV4 : DPSS_Data_Types::Position_Type = prev(pos_UAV4, initial_pos_UAV4);			
			eq pre_pos_UAV5 : DPSS_Data_Types::Position_Type = prev(pos_UAV5, initial_pos_UAV5);			
			eq pre_pos_UAV6 : DPSS_Data_Types::Position_Type = prev(pos_UAV6, initial_pos_UAV6);
			
			--Previous directions
			eq pre_direction_UAV1 : DPSS_Data_Types::Direction_Type = prev(direction_UAV1, suggested_initial_direction_UAV1);
			eq pre_direction_UAV2 : DPSS_Data_Types::Direction_Type = prev(direction_UAV2, suggested_initial_direction_UAV2);
			eq pre_direction_UAV3 : DPSS_Data_Types::Direction_Type = prev(direction_UAV3, suggested_initial_direction_UAV3);
			eq pre_direction_UAV4 : DPSS_Data_Types::Direction_Type = prev(direction_UAV4, suggested_initial_direction_UAV4);
			eq pre_direction_UAV5 : DPSS_Data_Types::Direction_Type = prev(direction_UAV5, suggested_initial_direction_UAV5);
			eq pre_direction_UAV6 : DPSS_Data_Types::Direction_Type = prev(direction_UAV6, suggested_initial_direction_UAV6);
			
			--Previous goals
			eq pre_goal_UAV1 : DPSS_Data_Types::Position_Type = prev(goal_UAV1, (if direction_UAV1 = 1 then DPSS_Constants.P_GLOBAL else 0.0));
			eq pre_goal_UAV2 : DPSS_Data_Types::Position_Type = prev(goal_UAV2, (if direction_UAV2 = 1 then DPSS_Constants.P_GLOBAL else 0.0));
			eq pre_goal_UAV3 : DPSS_Data_Types::Position_Type = prev(goal_UAV3, (if direction_UAV3 = 1 then DPSS_Constants.P_GLOBAL else 0.0));
			eq pre_goal_UAV4 : DPSS_Data_Types::Position_Type = prev(goal_UAV4, (if direction_UAV4 = 1 then DPSS_Constants.P_GLOBAL else 0.0));
			eq pre_goal_UAV5 : DPSS_Data_Types::Position_Type = prev(goal_UAV5, (if direction_UAV5 = 1 then DPSS_Constants.P_GLOBAL else 0.0));
			eq pre_goal_UAV6 : DPSS_Data_Types::Position_Type = prev(goal_UAV6, (if direction_UAV6 = 1 then DPSS_Constants.P_GLOBAL else 0.0));
						
			--Times to reach neighbors													
			eq time_to_reach_neighbor_12 : DPSS_Data_Types::Time_Type =
				DPSS_Node_Lib.time_to_reach_neighbor(pre_direction_UAV1,
														pre_direction_UAV2,
														pre_pos_UAV1,
														pre_pos_UAV2
														);
																		
			eq time_to_reach_neighbor_23 : DPSS_Data_Types::Time_Type = 
				DPSS_Node_Lib.time_to_reach_neighbor(pre_direction_UAV2,
														pre_direction_UAV3,
														pre_pos_UAV2,
														pre_pos_UAV3
														);
			
			eq time_to_reach_neighbor_34 : DPSS_Data_Types::Time_Type = 
				DPSS_Node_Lib.time_to_reach_neighbor(pre_direction_UAV3,
														pre_direction_UAV4,
														pre_pos_UAV3,
														pre_pos_UAV4
														);

			eq time_to_reach_neighbor_45 : DPSS_Data_Types::Time_Type = 
				DPSS_Node_Lib.time_to_reach_neighbor(pre_direction_UAV4,
														pre_direction_UAV5,
														pre_pos_UAV4,
														pre_pos_UAV5
														);
			
			eq time_to_reach_neighbor_56 : DPSS_Data_Types::Time_Type = 
				DPSS_Node_Lib.time_to_reach_neighbor(pre_direction_UAV5,
														pre_direction_UAV6,
														pre_pos_UAV5,
														pre_pos_UAV6
														);

			--Times to reach goals
			eq time_until_UAV1_reaches_goal : DPSS_Data_Types::Time_Type = 
				DPSS_Node_Lib.time_to_reach_target_position(
					pre_direction_UAV1, 
					pre_pos_UAV1, 
					pre_goal_UAV1
				);
				
			eq time_until_UAV2_reaches_goal : DPSS_Data_Types::Time_Type = 
				DPSS_Node_Lib.time_to_reach_target_position(
					pre_direction_UAV2, 
					pre_pos_UAV2, 
					pre_goal_UAV2
				);
				
			eq time_until_UAV3_reaches_goal : DPSS_Data_Types::Time_Type = 
				DPSS_Node_Lib.time_to_reach_target_position(
					pre_direction_UAV3, 
					pre_pos_UAV3, 
					pre_goal_UAV3
				);
			
			eq time_until_UAV4_reaches_goal : DPSS_Data_Types::Time_Type = 
				DPSS_Node_Lib.time_to_reach_target_position(
					pre_direction_UAV4, 
					pre_pos_UAV4, 
					pre_goal_UAV4
				);

			eq time_until_UAV5_reaches_goal : DPSS_Data_Types::Time_Type = 
				DPSS_Node_Lib.time_to_reach_target_position(
					pre_direction_UAV5, 
					pre_pos_UAV5, 
					pre_goal_UAV5
				);			
				
			eq time_until_UAV6_reaches_goal : DPSS_Data_Types::Time_Type = 
				DPSS_Node_Lib.time_to_reach_target_position(
					pre_direction_UAV6, 
					pre_pos_UAV6, 
					pre_goal_UAV6
				);
			
			eq deltaT : DPSS_Data_Types::Time_Type = 
							DPSS_Node_Lib.min_time(time_until_UAV1_reaches_goal,
							DPSS_Node_Lib.min_time(time_until_UAV2_reaches_goal,
							DPSS_Node_Lib.min_time(time_until_UAV3_reaches_goal,
							DPSS_Node_Lib.min_time(time_until_UAV4_reaches_goal,
							DPSS_Node_Lib.min_time(time_until_UAV5_reaches_goal,
							DPSS_Node_Lib.min_time(time_until_UAV6_reaches_goal,
							DPSS_Node_Lib.min_time(time_to_reach_neighbor_12,
							DPSS_Node_Lib.min_time(time_to_reach_neighbor_23,
							DPSS_Node_Lib.min_time(time_to_reach_neighbor_34,
							DPSS_Node_Lib.min_time(time_to_reach_neighbor_45,
												   time_to_reach_neighbor_56))))))))));
			
			eq stable : bool = 
				--Either
				(	--the UAVs are at 0, S_23, S_23, S_45, S_45, and P, respectively
					(
						pos_UAV1 = 0.0 and 
						pos_UAV2 = S_23 and 
						pos_UAV3 = S_23 and 
						pos_UAV4 = S_45 and
						pos_UAV5 = S_45 and
						pos_UAV6 = DPSS_Constants.P_GLOBAL
						)
					--and were previously at S_12, S_12, S_34, S_34, S_56, and S_56, respectively
					and (
						pre_pos_UAV1 = S_12 and 
						pre_pos_UAV2 = S_12 and 
						pre_pos_UAV3 = S_34 and 
						pre_pos_UAV4 = S_34 and
						pre_pos_UAV5 = S_56 and
						pre_pos_UAV6 = S_56
					)
				)
				--or
				or (--the UAVs are at S_12, S_12, S_34, S_34, S_56, and S_56, respectively
					(
						pos_UAV1 = S_12 and 
						pos_UAV2 = S_12 and 
						pos_UAV3 = S_34 and 
						pos_UAV4 = S_34 and
						pos_UAV5 = S_56 and
						pos_UAV6 = S_56
					)
					--and were previously at 0, S_23, S_23, S_45, S_45, and P, respectively
					and (
						pre_pos_UAV1 = 0.0 and 
						pre_pos_UAV2 = S_23 and 
						pre_pos_UAV3 = S_23 and 
						pre_pos_UAV4 = S_45 and
						pre_pos_UAV5 = S_45 and
						pre_pos_UAV6 = DPSS_Constants.P_GLOBAL
					)
				);
			
			-----------------------------------------------------
			--ASSUMPTIONS
			-----------------------------------------------------
			
			assume "time update": time = (0.0 -> pre(time) + deltaT);
			
			assume "UAVs are numbered according to their position from left to right":
				(	initial_pos_UAV1 <= initial_pos_UAV2
				and initial_pos_UAV2 <= initial_pos_UAV3
				and initial_pos_UAV3 <= initial_pos_UAV4
				and initial_pos_UAV4 <= initial_pos_UAV5
				and initial_pos_UAV5 <= initial_pos_UAV6
				)
				-> true;
				
			assume "Initial positions are between 0 and P_GLOBAL":
				(--Initial positions are >= 0
					0.0 <= initial_pos_UAV1 
				and 0.0 <= initial_pos_UAV2
				and 0.0 <= initial_pos_UAV3
				and 0.0 <= initial_pos_UAV4
				and 0.0 <= initial_pos_UAV5
				and 0.0 <= initial_pos_UAV6
				--and initial positions are <= P
				and initial_pos_UAV1 <= DPSS_Constants.P_GLOBAL
 				and initial_pos_UAV2 <= DPSS_Constants.P_GLOBAL
 				and initial_pos_UAV3 <= DPSS_Constants.P_GLOBAL
				and initial_pos_UAV4 <= DPSS_Constants.P_GLOBAL
				and initial_pos_UAV5 <= DPSS_Constants.P_GLOBAL
				and initial_pos_UAV6 <= DPSS_Constants.P_GLOBAL
				)
				-> true;
				
			assume "Suggested initial directions are LEFT or RIGHT":
				((			suggested_initial_direction_UAV1 = DPSS_Constants.LEFT
						or  suggested_initial_direction_UAV1 = DPSS_Constants.RIGHT)
					and (	suggested_initial_direction_UAV2 = DPSS_Constants.LEFT
						or 	suggested_initial_direction_UAV2 = DPSS_Constants.RIGHT)
					and (	suggested_initial_direction_UAV3 = DPSS_Constants.LEFT
						or 	suggested_initial_direction_UAV3 = DPSS_Constants.RIGHT)
					and (	suggested_initial_direction_UAV4 = DPSS_Constants.LEFT
						or  suggested_initial_direction_UAV4 = DPSS_Constants.RIGHT)
					and (	suggested_initial_direction_UAV5 = DPSS_Constants.LEFT
						or  suggested_initial_direction_UAV5 = DPSS_Constants.RIGHT)
					and (	suggested_initial_direction_UAV6 = DPSS_Constants.LEFT
						or  suggested_initial_direction_UAV6 = DPSS_Constants.RIGHT)
				)
				-> true;

			-----------------------------------------------------
			--GUARANTEES
			-----------------------------------------------------
			
			-- Main Theorem			
			guarantee "Theorem 1 for Algorithm A":
				(time >= ((2.0*DPSS_Constants.N_real - 1.0)/DPSS_Constants.N_real)*DPSS_Constants.Time_to_travel_full_length) =>
					(stable	and deltaT = DPSS_Constants.Time_to_travel_full_length/DPSS_Constants.N_real);
			
			guarantee "Initial positions are the input initial positions":
				(	pos_UAV1 = initial_pos_UAV1
				and pos_UAV2 = initial_pos_UAV2
				and pos_UAV3 = initial_pos_UAV3
				and pos_UAV4 = initial_pos_UAV4
				and pos_UAV5 = initial_pos_UAV5
				and pos_UAV6 = initial_pos_UAV6
				) -> true;
			
			guarantee "Goals are in bounds":
				--Goals are >= 0
					0.0 <= goal_UAV1
				and 0.0 <= goal_UAV2
				and 0.0 <= goal_UAV3
				and 0.0 <= goal_UAV4
				and 0.0 <= goal_UAV5
				and 0.0 <= goal_UAV6
				--and goals are <= P
				and goal_UAV1 <= DPSS_Constants.P_GLOBAL	
				and goal_UAV2 <= DPSS_Constants.P_GLOBAL
				and goal_UAV3 <= DPSS_Constants.P_GLOBAL
				and goal_UAV4 <= DPSS_Constants.P_GLOBAL
				and goal_UAV5 <= DPSS_Constants.P_GLOBAL
				and goal_UAV6 <= DPSS_Constants.P_GLOBAL;	
			
			guarantee "Positions are in bounds":
				--Positions are >= 0
					0.0 <= pos_UAV1
				and 0.0 <= pos_UAV2 
				and 0.0 <= pos_UAV3
				and 0.0 <= pos_UAV4
				and 0.0 <= pos_UAV5
				and 0.0 <= pos_UAV6
				--and positions are <= P
				and pos_UAV1 <= DPSS_Constants.P_GLOBAL
				and pos_UAV2 <= DPSS_Constants.P_GLOBAL
				and pos_UAV3 <= DPSS_Constants.P_GLOBAL
				and pos_UAV4 <= DPSS_Constants.P_GLOBAL
				and pos_UAV5 <= DPSS_Constants.P_GLOBAL
				and pos_UAV6 <= DPSS_Constants.P_GLOBAL;
			
			guarantee "UAVs stay in order":
					pos_UAV1 <= pos_UAV2
				and pos_UAV2 <= pos_UAV3
				and pos_UAV3 <= pos_UAV4
				and pos_UAV4 <= pos_UAV5
				and pos_UAV5 <= pos_UAV6;
			
			guarantee "UAVs turn around at the borders":
				--UAVs turn around at 0
					pos_UAV1 = 0.0 => direction_UAV1 = 1
				and pos_UAV2 = 0.0 => direction_UAV2 = 1
				and pos_UAV3 = 0.0 => direction_UAV3 = 1
				and pos_UAV4 = 0.0 => direction_UAV4 = 1
				and pos_UAV5 = 0.0 => direction_UAV5 = 1
				and pos_UAV6 = 0.0 => direction_UAV6 = 1
				--and UAVs turn around at P
				and pos_UAV1 = DPSS_Constants.P_GLOBAL => direction_UAV1 = -1
				and pos_UAV2 = DPSS_Constants.P_GLOBAL => direction_UAV2 = -1
				and pos_UAV3 = DPSS_Constants.P_GLOBAL => direction_UAV3 = -1
				and pos_UAV4 = DPSS_Constants.P_GLOBAL => direction_UAV4 = -1
				and pos_UAV5 = DPSS_Constants.P_GLOBAL => direction_UAV5 = -1
				and pos_UAV6 = DPSS_Constants.P_GLOBAL => direction_UAV6 = -1;
				
			guarantee "Directions are in bounds":
				(	 direction_UAV1 = 1 or direction_UAV1 = -1)
				and (direction_UAV2 = 1 or direction_UAV2 = -1)
				and (direction_UAV3 = 1 or direction_UAV3 = -1)
				and (direction_UAV4 = 1 or direction_UAV4 = -1)
				and (direction_UAV5 = 1 or direction_UAV5 = -1)
				and (direction_UAV6 = 1 or direction_UAV6 = -1);
			
		**};
		
	end DPSS_6_Vehicles;

	system implementation DPSS_6_Vehicles.Impl
		subcomponents
			UAV1: system UAV_Pkg::UAV;
			UAV2: system UAV_Pkg::UAV;
			UAV3: system UAV_Pkg::UAV;
			UAV4: system UAV_Pkg::UAV;
			UAV5: system UAV_Pkg::UAV;
			UAV6: system UAV_Pkg::UAV;
			
		connections
			--Suggested initial directions
			sug_init_dir_UAV1: port	suggested_initial_direction_UAV1 -> UAV1.suggested_initial_direction;
			sug_init_dir_UAV2: port	suggested_initial_direction_UAV2 -> UAV2.suggested_initial_direction;
			sug_init_dir_UAV3: port	suggested_initial_direction_UAV3 -> UAV3.suggested_initial_direction;
			sug_init_dir_UAV4: port	suggested_initial_direction_UAV4 -> UAV4.suggested_initial_direction;
			sug_init_dir_UAV5: port	suggested_initial_direction_UAV5 -> UAV5.suggested_initial_direction;
			sug_init_dir_UAV6: port	suggested_initial_direction_UAV6 -> UAV6.suggested_initial_direction;
			
			--Initial positions
			init_pos_UAV1: port initial_pos_UAV1 -> UAV1.initial_position;
			init_pos_UAV2: port initial_pos_UAV2 -> UAV2.initial_position;
			init_pos_UAV3: port initial_pos_UAV3 -> UAV3.initial_position;
			init_pos_UAV4: port initial_pos_UAV4 -> UAV4.initial_position;
			init_pos_UAV5: port initial_pos_UAV5 -> UAV5.initial_position;
			init_pos_UAV6: port initial_pos_UAV6 -> UAV6.initial_position;
			
			--Connections between neighbors for sharing positions
			--Share position with right neighbor (get left neighbor position)
			pos_UAV1_to_UAV2 : port UAV1.pos -> UAV2.pos_LN;
			pos_UAV2_to_UAV3 : port UAV2.pos -> UAV3.pos_LN;
			pos_UAV3_to_UAV4 : port UAV3.pos -> UAV4.pos_LN;
			pos_UAV4_to_UAV5 : port UAV4.pos -> UAV5.pos_LN;	
			pos_UAV5_to_UAV6 : port UAV5.pos -> UAV6.pos_LN;
			--Share position with left neighbor (get right neighbor position)
			pos_UAV2_to_UAV1 : port UAV2.pos -> UAV1.pos_RN;
			pos_UAV3_to_UAV2 : port UAV3.pos -> UAV2.pos_RN;
			pos_UAV4_to_UAV3 : port UAV4.pos -> UAV3.pos_RN;
			pos_UAV5_to_UAV4 : port UAV5.pos -> UAV4.pos_RN;
			pos_UAV6_to_UAV5 : port UAV6.pos -> UAV5.pos_RN;
			
			--Output positions of the UAVs
			pos_UAV1_output : port UAV1.pos -> pos_UAV1;
			pos_UAV2_output : port UAV2.pos -> pos_UAV2;
			pos_UAV3_output : port UAV3.pos -> pos_UAV3;
			pos_UAV4_output : port UAV4.pos -> pos_UAV4;
			pos_UAV5_output : port UAV5.pos -> pos_UAV5;
			pos_UAV6_output : port UAV6.pos -> pos_UAV6;
						
		annex agree {**

			--Assign direction variables (used at the system level)
			assign direction_UAV1 = UAV1.direction;
			assign direction_UAV2 = UAV2.direction;			
			assign direction_UAV3 = UAV3.direction;
			assign direction_UAV4 = UAV4.direction;
			assign direction_UAV5 = UAV5.direction;
			assign direction_UAV6 = UAV6.direction;
												
			--Assign goal variables (used at the system level)
			assign goal_UAV1 = UAV1.goal;
			assign goal_UAV2 = UAV2.goal;
			assign goal_UAV3 = UAV3.goal;			
			assign goal_UAV4 = UAV4.goal;
			assign goal_UAV5 = UAV5.goal;
			assign goal_UAV6 = UAV6.goal;
			
			--Set UAV IDs
			--We use assertions since the IDs are not system-level inputs that we can pass through			
			assert UAV1.id = 1;
			assert UAV2.id = 2;			
			assert UAV3.id = 3;
			assert UAV4.id = 4;	
			assert UAV5.id = 5;	
			assert UAV6.id = 6;
															
			--Since the leftmost UAV has no left neighbor, set pos_LN to something to the left of the left endpoint (so UAV1 never meets its "phantom" neighbor).
			assert UAV1.pos_LN = -1.0; 

			--Since the rightmost UAV has no right neighbor, set pos_RN to something to the right of the right endpoint (so UAVN never meets its "phantom" neighbor).
			assert UAV6.pos_RN = DPSS_Constants.P_GLOBAL + 1.0;
			
			--Used in lemmas
			eq steps : int = 1 -> pre(steps + 1);
			
			--Expected number of steps it takes to converge to the stable configuration
			--We don't know what this is yet for N = 6 UAVs.
			--eq steps_to_converge : int = ??;
			
			----------------------------------------------------------------------------
			--OBSERVERS (Invalid lemmas that produce examples of behavior of interest)
			----------------------------------------------------------------------------
						
			lemma "Observer: Worst time convergence":
				not (
					stable
					--Initially, all UAVs are heading to the right
					and DPSS_Node_Lib.initial_value_true(direction_UAV1 = 1)
					and DPSS_Node_Lib.initial_value_true(direction_UAV2 = 1)
					and DPSS_Node_Lib.initial_value_true(direction_UAV3 = 1)
					and DPSS_Node_Lib.initial_value_true(direction_UAV4 = 1)
					and DPSS_Node_Lib.initial_value_true(direction_UAV5 = 1)
					and DPSS_Node_Lib.initial_value_true(direction_UAV6 = 1)
					--and the UAVs are located close together on the left end of the perimeter
					and DPSS_Node_Lib.initial_value_true(pos_UAV1 = 0.0)
					and DPSS_Node_Lib.initial_value_true(pos_UAV2 = 0.01)
					and DPSS_Node_Lib.initial_value_true(pos_UAV3 = 0.02)
					and DPSS_Node_Lib.initial_value_true(pos_UAV4 = 0.03)
					and DPSS_Node_Lib.initial_value_true(pos_UAV5 = 0.04)
					and DPSS_Node_Lib.initial_value_true(pos_UAV6 = 0.05)
				);

--We don't yet know how many steps it will take to converge for N = 6.			
--			lemma "Observer: Worst steps convergence (not yet stable after ?? steps)":
--				steps = steps_to_converge - 1 => stable;
			
			----------------------------------------------------------------------------
			--LEMMAS (We expect these to be true and to potentially help the model checker prove the guarantees)
			----------------------------------------------------------------------------			
			
			--UAVs stay in bounds (prove one at a time)	
			lemma "UAV1 stays in bounds": 0.0 <= pos_UAV1 and pos_UAV1 <= DPSS_Constants.P_GLOBAL;
			lemma "UAV2 stays in bounds": 0.0 <= pos_UAV2 and pos_UAV2 <= DPSS_Constants.P_GLOBAL;
			lemma "UAV3 stays in bounds": 0.0 <= pos_UAV3 and pos_UAV3 <= DPSS_Constants.P_GLOBAL;			
			lemma "UAV4 stays in bounds": 0.0 <= pos_UAV4 and pos_UAV4 <= DPSS_Constants.P_GLOBAL;
			lemma "UAV5 stays in bounds": 0.0 <= pos_UAV5 and pos_UAV5 <= DPSS_Constants.P_GLOBAL;
			lemma "UAV6 stays in bounds": 0.0 <= pos_UAV6 and pos_UAV6 <= DPSS_Constants.P_GLOBAL;
						
			lemma "Once stable, stays stable":
				true -> pre(stable) => stable;

			lemma "Stable on and after 24 steps":
				steps >= 24 => stable;
			
			lemma "Stable on and after 25 steps":
				steps >= 25 => stable;
			
			lemma "Stable on and after 26 steps":
				steps >= 26 => stable;
			
			lemma "Stable on and after 27 steps":
				steps >= 27 => stable;
				
			lemma "Stable on and after 28 steps":
				steps >= 28 => stable;
			
			lemma "Stable on and after 29 steps":
				steps >= 29 => stable;
					
			lemma "Stable implies deltaT = T/N":
				stable => deltaT = DPSS_Constants.Time_to_travel_full_length/DPSS_Constants.N_real;
			
			lemma "deltaT is strictly between 0 and T":
				true -> (
					deltaT > 0.0 
					and deltaT < DPSS_Constants.Time_to_travel_full_length
					);
			
			-- This is a good way to find the real time bound!
 			-- The lemma is valid for time < 2T but not for time < (2-1/N)T.
 			-- I believe it would be valid with (2-1/N)T if we only required one timestep of stability instead of two. 			
			lemma "Time to become stable is less than 2T":
				(stable and not (pre(stable))) => 
					(time < 2.0*DPSS_Constants.Time_to_travel_full_length);
			
		**};
		
	end DPSS_6_Vehicles.Impl;

end DPSS_6_Vehicles_Pkg;