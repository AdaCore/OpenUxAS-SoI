package DPSS_3_Vehicles_Pkg
public
	with Base_Types;
	with DPSS_Data_Types;
	with DPSS_Node_Lib;
	with DPSS_Constants;
	with UAV_Pkg;
	
	system DecentPerimSurv
		features
			--Inputs:
			initial_pos_UAV1 : in data port DPSS_Data_Types::Position_Type;
			suggested_initial_direction_UAV1 : in data port DPSS_Data_Types::Direction_Type;
			initial_pos_UAV2 : in data port DPSS_Data_Types::Position_Type;
			suggested_initial_direction_UAV2 : in data port DPSS_Data_Types::Direction_Type;
			initial_pos_UAV3 : in data port DPSS_Data_Types::Position_Type;
			suggested_initial_direction_UAV3 : in data port DPSS_Data_Types::Direction_Type;
			
			--Outputs:
			pos_UAV1 : out data port DPSS_Data_Types::Position_Type;
			pos_UAV2 : out data port DPSS_Data_Types::Position_Type;
			pos_UAV3 : out data port DPSS_Data_Types::Position_Type;
			 
		annex agree {**
			const N : Base_Types::Integer = 3;
			eq direction_UAV1 : DPSS_Data_Types::Direction_Type;
			eq direction_UAV2 : DPSS_Data_Types::Direction_Type;
			eq direction_UAV3 : DPSS_Data_Types::Direction_Type;
			
			assume "time update": time = (0.0 -> pre(time) + deltaT);
			
			eq goal_UAV1 : DPSS_Data_Types::Position_Type;
			eq goal_UAV2 : DPSS_Data_Types::Position_Type;
			eq goal_UAV3 : DPSS_Data_Types::Position_Type;
			
			--Shared border positions
			eq S_12 : DPSS_Data_Types::Position_Type = 
				real(1)*DPSS_Constants.P_GLOBAL/real(N);  
			eq S_23 : DPSS_Data_Types::Position_Type = 
				real(2)*DPSS_Constants.P_GLOBAL/real(N);
			
			--Previous positions
			eq pre_pos_UAV1 : DPSS_Data_Types::Position_Type = 
				prev(pos_UAV1, initial_pos_UAV1);
			eq pre_pos_UAV2 : DPSS_Data_Types::Position_Type = 
				prev(pos_UAV2, initial_pos_UAV2);
			eq pre_pos_UAV3 : DPSS_Data_Types::Position_Type = 
				prev(pos_UAV3, initial_pos_UAV3);
			
			--Previous directions
			eq pre_direction_UAV1 : DPSS_Data_Types::Direction_Type = 
				prev(direction_UAV1, suggested_initial_direction_UAV1);
			eq pre_direction_UAV2 : DPSS_Data_Types::Direction_Type = 
				prev(direction_UAV2, suggested_initial_direction_UAV2);
			eq pre_direction_UAV3 : DPSS_Data_Types::Direction_Type = 
				prev(direction_UAV3, suggested_initial_direction_UAV3);
			
			--Previous goals
			eq pre_goal_UAV1 : DPSS_Data_Types::Position_Type = 
				prev(goal_UAV1, (if direction_UAV1 = 1 then DPSS_Constants.P_GLOBAL else 0.0));
			eq pre_goal_UAV2 : DPSS_Data_Types::Position_Type = 
				prev(goal_UAV2, (if direction_UAV2 = 1 then DPSS_Constants.P_GLOBAL else 0.0));
			eq pre_goal_UAV3 : DPSS_Data_Types::Position_Type = 
				prev(goal_UAV3, (if direction_UAV3 = 1 then DPSS_Constants.P_GLOBAL else 0.0));
						
			--Times to reach neighbors													)
			eq time_to_reach_neighbor_12 : DPSS_Data_Types::Time_Type = 
				DPSS_Node_Lib.time_to_reach_neighbor(pre_direction_UAV1,
														pre_direction_UAV2,
														pre_pos_UAV1,
														pre_pos_UAV2
														);
																		
			eq time_to_reach_neighbor_23 : DPSS_Data_Types::Time_Type = 
				DPSS_Node_Lib.time_to_reach_neighbor(pre_direction_UAV2,
														pre_direction_UAV3,
														pre_pos_UAV2,
														pre_pos_UAV3
														);
			--Times to reach goals
			eq time_until_UAV1_reaches_goal : DPSS_Data_Types::Time_Type = 
				DPSS_Node_Lib.time_to_reach_target_position(
					pre_direction_UAV1, 
					pre_pos_UAV1, 
					pre_goal_UAV1
				);
				
			eq time_until_UAV2_reaches_goal : DPSS_Data_Types::Time_Type = 
				DPSS_Node_Lib.time_to_reach_target_position(
					pre_direction_UAV2, 
					pre_pos_UAV2, 
					pre_goal_UAV2
				);
				
			eq time_until_UAV3_reaches_goal : DPSS_Data_Types::Time_Type = 
				DPSS_Node_Lib.time_to_reach_target_position(
					pre_direction_UAV3, 
					pre_pos_UAV3, 
					pre_goal_UAV3
				);
			
			--These Booleans are true iff the neighbors meet (i.e., are co-located) on this timestep.
			eq meet_neighbor_12 : bool = (pos_UAV1 = pos_UAV2); 
			eq meet_neighbor_23 : bool = (pos_UAV2 = pos_UAV3); 
			
			eq deltaT : DPSS_Data_Types::Time_Type = DPSS_Node_Lib.min_time(time_until_UAV1_reaches_goal,
								DPSS_Node_Lib.min_time(time_until_UAV2_reaches_goal,
									DPSS_Node_Lib.min_time(time_until_UAV3_reaches_goal,
										DPSS_Node_Lib.min_time(time_to_reach_neighbor_12,
											time_to_reach_neighbor_23))));
			
			assume "UAVs are numbered according to their position from left to right":
				initial_pos_UAV1 <= initial_pos_UAV2
				and initial_pos_UAV2 <= initial_pos_UAV3;
				
			assume "Initial positions are between 0 and P_GLOBAL":
				0.0 <= initial_pos_UAV1 
				and initial_pos_UAV1 <= DPSS_Constants.P_GLOBAL
				and 0.0 <= initial_pos_UAV2 
				and initial_pos_UAV2 <= DPSS_Constants.P_GLOBAL
				and 0.0 <= initial_pos_UAV3 
				and initial_pos_UAV3 <= DPSS_Constants.P_GLOBAL;
				
			assume "Suggested initial directions are LEFT or RIGHT":
				(suggested_initial_direction_UAV1 = DPSS_Constants.LEFT
					or suggested_initial_direction_UAV1 = DPSS_Constants.RIGHT)
				and (suggested_initial_direction_UAV2 = DPSS_Constants.LEFT
					or suggested_initial_direction_UAV2 = DPSS_Constants.RIGHT)
				and (suggested_initial_direction_UAV3 = DPSS_Constants.LEFT
					or suggested_initial_direction_UAV3 = DPSS_Constants.RIGHT);
			
			guarantee "Theorem 1 for Algorithm A for Three Vehicles":
				time >= 1.67*DPSS_Constants.Time_to_travel_full_length =>
					((((pos_UAV1 = 0.0 and pos_UAV2 = S_23 and pos_UAV3 = S_23)
							and (pre_pos_UAV1 = S_12 and pre_pos_UAV2 = S_12 and pre_pos_UAV3 = DPSS_Constants.P_GLOBAL))
						or ((pos_UAV1 = S_12 and pos_UAV2 = S_12 and pos_UAV3 = DPSS_Constants.P_GLOBAL)
							and (pre_pos_UAV1 = 0.0 and pre_pos_UAV2 = S_23 and pre_pos_UAV3 = S_23)
						))
					and 
						(deltaT = DPSS_Constants.Time_to_travel_full_length/real(N))
					);
			
		**};
		
	end DecentPerimSurv;

	system implementation DecentPerimSurv.Impl
		subcomponents
			UAV1: system UAV_Pkg::UAV;
			UAV2: system UAV_Pkg::UAV;
			UAV3: system UAV_Pkg::UAV;
		connections
			sug_init_dir_UAV1: port	suggested_initial_direction_UAV1 -> UAV1.suggested_initial_direction;
			sug_init_dir_UAV2: port	suggested_initial_direction_UAV2 -> UAV2.suggested_initial_direction;
			sug_init_dir_UAV3: port	suggested_initial_direction_UAV3 -> UAV3.suggested_initial_direction;
						
		annex agree {**
			--UAV1 outputs
			assign direction_UAV1 = UAV1.direction;
			assign goal_UAV1 = UAV1.goal;
			
			--UAV1 inputs
			assert UAV1.meet_LN = false;
			assert UAV1.meet_RN = meet_neighbor_12;
			assert UAV1.id = 1;
			assert UAV1.N = N;
			assert UAV1.pos = pos_UAV1;
						
			--UAV2 outputs
			assign direction_UAV2 = UAV2.direction;
			assign goal_UAV2 = UAV2.goal;
			
			--UAV2 inputs
			assert UAV2.meet_LN = meet_neighbor_12;
			assert UAV2.meet_RN = meet_neighbor_23;
			assert UAV2.id = 2;
			assert UAV2.N = N;
			assert UAV2.pos = pos_UAV2;
			
			--UAV3 outputs
			assign direction_UAV3 = UAV3.direction;
			assign goal_UAV3 = UAV3.goal;
			
			--UAV3 inputs
			assert UAV3.meet_LN = meet_neighbor_23;
			assert UAV3.meet_RN = false;
			assert UAV3.id = 3;
			assert UAV3.N = N;
			assert UAV3.pos = pos_UAV3;
			
			--Update positions
			assign pos_UAV1 = (initial_pos_UAV1 ->
						if pre_direction_UAV1 = 1 then
							pre_pos_UAV1 + DPSS_Constants.V*deltaT
						else --direction = -1
							pre_pos_UAV1 - DPSS_Constants.V*deltaT);
			
			assign pos_UAV2 = (initial_pos_UAV2 ->
						if pre_direction_UAV2 = 1 then
							pre_pos_UAV2 + DPSS_Constants.V*deltaT
						else --direction = -1
							pre_pos_UAV2 - DPSS_Constants.V*deltaT);
			
			assign pos_UAV3 = (initial_pos_UAV3 ->
						if pre_direction_UAV3 = 1 then
							pre_pos_UAV3 + DPSS_Constants.V*deltaT
						else --direction = -1
							pre_pos_UAV3 - DPSS_Constants.V*deltaT);
				
		**};
		
	end DecentPerimSurv.Impl;

end DPSS_3_Vehicles_Pkg;