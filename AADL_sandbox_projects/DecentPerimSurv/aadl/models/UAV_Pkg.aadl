package UAV_Pkg
public
	with DPSS_Data_Types;
	with Base_Types;
	with DPSS_Constants;
	
	system UAV
		features
			--inputs
			suggested_initial_direction : in data port DPSS_Data_Types::Direction_Type; --The UAV may choose a different direction for the initial timestep, depending on the circumstances.
			initial_position : in data port DPSS_Data_Types::Position_Type;
			pos_LN : in data port DPSS_Data_Types::Position_Type; --Position of left neighbor (< 0  if there is no left neighbor)
			pos_RN : in data port DPSS_Data_Types::Position_Type; --Position of right neighbor (> P_GLOBAL if there is no right neighbor)
			id : in data port Base_Types::Integer; --a positive integer between 1 and N
			N : in data port Base_Types::Integer; --a positive integer
			
			--outputs
			direction: out data port DPSS_Data_Types::Direction_Type;
			goal : out data port DPSS_Data_Types::Position_Type;
			pos : out data port DPSS_Data_Types::Position_Type;
					
		annex agree {**
			--Shared border positions
			eq S_L : DPSS_Data_Types::Position_Type = 
				real(id-1)*DPSS_Constants.P_GLOBAL/real(N);  
			eq S_R : DPSS_Data_Types::Position_Type = 
				real(id)*DPSS_Constants.P_GLOBAL/real(N);	
				
			--Previous direction
			eq pre_direction : DPSS_Data_Types::Direction_Type = 
				prev(direction, suggested_initial_direction);
				
			--Previous position
			eq pre_pos : DPSS_Data_Types::Position_Type =
				prev(pos, initial_position);
			
			--These Booleans are true iff the neighbors meet (i.e., are co-located) on this timestep. 
			eq meet_LN : bool = (pos_LN = pos); --Meet left neighbor?
			eq meet_RN : bool = (pos_RN = pos); --Meet right neighbor?
							
			--Assumptions
			assume "ID in range":
				id >= 1 and id <= N;
			
			assume "N is fixed":
				true -> (N = pre(N));
			
			assume "ID is fixed":
				true -> (id = pre(id));
			
			assume "Input initial position is between 0 and P_GLOBAL":
				(0.0 <= initial_position
				and initial_position <= DPSS_Constants.P_GLOBAL)
				-> true;
							
			assume "Suggested initial direction is LEFT or RIGHT":
				(suggested_initial_direction = DPSS_Constants.LEFT
					or suggested_initial_direction = DPSS_Constants.RIGHT)
				-> true;
			
			assume "ID = 1 implies pos_LN < 0":
				id = 1 => pos_LN < 0.0;
				
			assume "ID = N implies pos_RN > P_GLOBAL":
				id = N => pos_RN > DPSS_Constants.P_GLOBAL;
				
			assume "Middle UAV implies pos_LN <= pos <= pos_RN":
				(id > 1 and id < N) =>
					((pos_LN <= pos) and (pos <= pos_RN));
			
			assume "Time marches on":
				true -> (time >= pre(time));
			
			guarantee "Direction formula":
				direction = (
					if id = 1 then --leftmost, or only, UAV
						if meet_RN then
							if pos < S_R then
								1
							else --pos >= S_R
								-1
						else if pos <= 0.0 then
								1
							 --This case is possible if N = 1
							 else if pos >= DPSS_Constants.P_GLOBAL then
							 		-1
							 	  else
							 		pre_direction
					else if id = N then --rightmost UAV
						if meet_LN then
							if pos > S_L then
								-1
							else --pos_UAV3 <= S_L 
								1
						else if pos >= DPSS_Constants.P_GLOBAL then
								-1
							else 
								pre_direction
					else --a middle UAV
						if meet_LN then
							if pos <= S_L then
								1
							else --pos_UAV2 > S_L
								-1						
						else if meet_RN then
								if pos < S_R then
									1
								else --pos >= S_R
									-1 
							 else 
								pre_direction
				);  

			guarantee "Goal formula":
				goal = (
					if id = 1 then --leftmost, or only, UAV
						if meet_RN then
							if pos < S_R then
								S_R
							else --pos >= S_R 
								0.0
						else if direction = 1 then
								DPSS_Constants.P_GLOBAL
							else --direction = -1 
								0.0 
					else if id = N then --rightmost UAV
						if meet_LN then
							if pos > S_L then
								S_L
							else --pos <= S_L 
								DPSS_Constants.P_GLOBAL
						else if direction = 1 then
								DPSS_Constants.P_GLOBAL
							 else --direction = -1 
								0.0 
					else --a middle UAV
						if meet_LN then
							S_L
						else if meet_RN then
								S_R
							 else if direction = 1 then
									DPSS_Constants.P_GLOBAL
								  else --direction = -1 
									0.0 
				); 

			guarantee "Position formula":
				pos = (initial_position -> 
						(if pre_direction = 1 then
							pre_pos + DPSS_Constants.V*(time - pre(time))
						else --pre_direction = -1
							pre_pos - DPSS_Constants.V*(time - pre(time))));
			

		**};
		
	end UAV;
end UAV_Pkg;