package UAV_Pkg
public
	with DPSS_Data_Types;
	with Base_Types;
	
	system UAV
		features
			--inputs
			suggested_initial_direction : in data port DPSS_Data_Types::Direction_Type; --The UAV may choose a different direction for the initial timestep, depending on the circumstances.
			meet_LN : in data port Base_Types::Boolean; --True iff this UAV is co-located with it's left neighbor
			meet_RN : in data port Base_Types::Boolean;
			id : in data port Base_Types::Integer; --a positive integer between 1 and N
			N : in data port Base_Types::Integer; --a positive integer
			pos : in data port DPSS_Data_Types::Position_Type;
			
			--outputs
			direction: out data port DPSS_Data_Types::Direction_Type;
			goal : out data port DPSS_Data_Types::Position_Type;
		
		annex agree {**
			--Shared border positions
			eq S_L : DPSS_Data_Types::Position_Type = 
				real(id-1)*DPSS_Constants.P_GLOBAL/real(N);  
			eq S_R : DPSS_Data_Types::Position_Type = 
				real(id)*DPSS_Constants.P_GLOBAL/real(N);	
				
			--Previous direction
			eq pre_direction : DPSS_Data_Types::Direction_Type = 
				prev(direction, suggested_initial_direction);
				
			--Assumptions
			assume "id in range":
				id >= 1 and id <= N;
			
			assume "N is fixed":
				true -> (N = pre(N));
			
			assume "id is fixed":
				true -> (id = pre(id));
			
			guarantee "direction formula":
				direction = (
					if id = 1 then --leftmost UAV
						if meet_RN then
							if pos < S_R then
								1
							else --pos >= S_R
								-1
						else if pos <= 0.0 then
								1
							 --This case is possible if N = 1
							 else if pos >= DPSS_Constants.P_GLOBAL then
							 		-1
							 	  else
							 		pre_direction
					else if id = N then --rightmost UAV
						if meet_LN then
							if pos > S_L then
								-1
							else --pos_UAV3 <= S_L 
								1
						else if pos >= DPSS_Constants.P_GLOBAL then
								-1
							else 
								pre_direction
					else --a middle UAV
						if meet_LN then
							if pos <= S_L then
								1
							else --pos_UAV2 > S_L
								-1						
						else if meet_RN then
								if pos < S_R then
									1
								else --pos >= S_R
									-1 
							 else 
								pre_direction
				);  

			guarantee "goal formula":
				goal = (
					if id = 1 then --leftmost UAV
						if meet_RN then
							if pos < S_R then
								S_R
							else --pos >= S_R 
								0.0
						else if direction = 1 then
								DPSS_Constants.P_GLOBAL
							else --direction = -1 
								0.0 
					else if id = N then --rightmost UAV
						if meet_LN then
							if pos > S_L then
								S_L
							else --pos <= S_L 
								DPSS_Constants.P_GLOBAL
						else if direction = 1 then
								DPSS_Constants.P_GLOBAL
							 else --direction = -1 
								0.0 
					else --a middle UAV
						if meet_LN then
							S_L
						else if meet_RN then
								S_R
							 else if direction = 1 then
									DPSS_Constants.P_GLOBAL
								  else --direction = -1 
									0.0 
				); 

		**};
		
	end UAV;
end UAV_Pkg;