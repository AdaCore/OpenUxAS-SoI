package IMPACT
public
	with CMASI;

	with Data_Model;
	with Base_Types;
	with Common_Data;
	renames Common_Data::all;
    
--Area Search Pattern
data AreaSearchPattern extends Base_Types::Integer
	properties
		Data_Model::Enumerators => (
			--Spiral search
			"Spiral",
			--Sector
			"Sector",
			--Sweep
			"Sweep");
end AreaSearchPattern;

data implementation AreaSearchPattern.i
end AreaSearchPattern.i;

--Vehicle Power Plant
data PowerPlant extends Base_Types::Integer
	properties
		Data_Model::Enumerators => (
			--Conventional gasoline
			"Gasoline",
			--Heavy Fuel (JP5)
			"JP5",
			--Heavy Fuel (JP8)
			"JP8",
			--Fuel Cell (Hydrogen)
			"FuelCell",
			--Hybrid electric/gasoline
			"Hybrid",
			--Primarily electric
			"Electric");
end PowerPlant;

data implementation PowerPlant.i
end PowerPlant.i;

--Fusion Area Actions
data AreaActionOptions extends Base_Types::Integer
	properties
		Data_Model::Enumerators => (
			--Object of interest created
			"Created",
			--Object of interest destroyed
			"Destroyed",
			--Object of interest modified
			"Modified");
end AreaActionOptions;

data implementation AreaActionOptions.i
end AreaActionOptions.i;

--Impact specific payload types
data ImpactPayloadType extends Base_Types::Integer
	properties
		Data_Model::Enumerators => (
			--Unknown
			"Unknown",
			--EO
			"EO",
			--Forward Looking Infra Red
			"FLIR",
			--Mid Wave Infra Red
			"MWIR",
			--LFIR
			"LFIR",
			--Auto-tracking payload
			"Track",
			--Placement of physical tag for tracking
			"Tag",
			--Megaphone
			"Megaphone",
			--Siren
			"Siren",
			--Search Light
			"SearchLight",
			--Browning .50 caliber weapon
			"FiftyCal",
			--M240B
			"M240B",
			--Flashbang
			"Flashbang",
			--Tear Gas
			"TearGas",
			--Taser
			"Taser",
			--Heat Beam
			"HeatBeam",
			--Scan Eagle Guided Munition
			"SEGM",
			--Comm Relay
			"CommRelay",
			--Ground Moving Target Indicator
			"GMTI",
			--Laser Designator
			"LaserDesignator",
			--LWIR
			"LWIR");
end ImpactPayloadType;

data implementation ImpactPayloadType.i
end ImpactPayloadType.i;

data PowerConfiguration extends CMASI::PayloadConfiguration
end PowerConfiguration;

--Indicates the power plant configuration carried by a vehicle
data implementation PowerConfiguration.i extends CMASI::PayloadConfiguration.i
	subcomponents
		--Power generation system (used for acoustic signature)
		NominalPowerConfiguration: data PowerPlant.i;
end PowerConfiguration.i;

data RadioConfiguration extends CMASI::PayloadConfiguration
end RadioConfiguration;

--Indicates the radio specification carried by an entity
data implementation RadioConfiguration.i extends CMASI::PayloadConfiguration.i
	subcomponents
		--The range of the radio
		Range: data real32.i;
		--The vehicle's rally point during loss of comm contingency. When set to null,
		--no defined loss of comm behavior.
		RallyPoint: data Location3D.i;
		--Time after loss of communications the vehicle should return to its rally point
		Timeout: data int64.i;
end RadioConfiguration.i;

data RadioTowerConfiguration extends CMASI::EntityConfiguration
end RadioTowerConfiguration;

--Indicates a radio tower
data implementation RadioTowerConfiguration.i extends CMASI::EntityConfiguration.i
	subcomponents
		--The position of the tower. A valid RadioTowerConfiguration must define Position
		--(null not allowed)
		Position: data Location3D.i;
		--The range of the radio
		Range: data real32.i;
		--Whether the radio is enabled
		Enabled: data bool.i;
end RadioTowerConfiguration.i;

data RadioState extends CMASI::PayloadState
end RadioState;

--Indicates the radio state
data implementation RadioState.i extends CMASI::PayloadState.i
	subcomponents
		--Whether the radio is enabled
		Enabled: data bool.i;
		--Whether the vehicle is in communications range
		InRange: data bool.i;
end RadioState.i;

data RadioTowerState extends CMASI::EntityState
end RadioTowerState;

--Indicates a radio tower state
data implementation RadioTowerState.i extends CMASI::EntityState.i
	subcomponents
		--Whether the radio is enabled
		Enabled: data bool.i;
end RadioTowerState.i;

data ImpactPayloadConfiguration extends CMASI::PayloadConfiguration
end ImpactPayloadConfiguration;

--Indicates the IMPACT specific payloads carried by an entity
data implementation ImpactPayloadConfiguration.i extends CMASI::PayloadConfiguration.i
	subcomponents
		--Payloads available for this entity
		AvailablePayloads: data ImpactPayloadType.i {Data_Model::Data_Representation => Array;};
end ImpactPayloadConfiguration.i;

data DeployImpactPayload extends CMASI::VehicleAction
end DeployImpactPayload;

--Indicator for use of an IMPACT payload
data implementation DeployImpactPayload.i extends CMASI::VehicleAction.i
	subcomponents
		--IMPACT vehicle from which to deploy payload
		VehicleID: data int64.i;
		--Payload to deploy
		DeployedPayload: data ImpactPayloadType.i;
		--Entity to which the payload will be deployed. If zero, then payload is assumed
		--deployed at the current position of the deploying vehicle.
		TargetEntityID: data int64.i;
end DeployImpactPayload.i;

data PowerPlantState extends CMASI::PayloadState
end PowerPlantState;

--Describes the current state of the power system
data implementation PowerPlantState.i extends CMASI::PayloadState.i
	subcomponents
		--The active power plant
		ActivePowerPlant: data PowerPlant.i;
end PowerPlantState.i;

data BatchRoutePlanRequest
end BatchRoutePlanRequest;

--Batch Route plan request. Plans from current vehicle locations to the start of
--each task in 'TaskList'
data implementation BatchRoutePlanRequest.i
	subcomponents
		--Request ID for correlating with response
		RequestID: data int64.i;
		--An array of vehicles (by ID) to consider when planning
		Vehicles: data int64.i {Data_Model::Data_Representation => Array;};
		--List of task IDs to be planned to
		TaskList: data int64.i {Data_Model::Data_Representation => Array;};
		--Operating region to be considered during planning
		OperatingRegion: data int64.i;
		--Flag to report timing between tasks
		ComputeTaskToTaskTiming: data bool.i;
		--Flag to report timing between incremental progress on task and subsequent tasks
		ComputeInterTaskToTaskTiming: data bool.i;
		--List of task percentages along task to plan from
		InterTaskPercentage: data real32.i {Data_Model::Data_Representation => Array;};
end BatchRoutePlanRequest.i;

data BatchRoutePlanResponse
end BatchRoutePlanResponse;

--Batch Route plan response with vehicle-to-task timing reported.
data implementation BatchRoutePlanResponse.i
	subcomponents
		--Response ID matching request from ({@link BatchRoutePlanRequest})
		ResponseID: data int64.i;
		--Set of task-to-task timings for each requested vehicle
		VehicleTiming: data TaskTimingPair.i {Data_Model::Data_Representation => Array;};
end BatchRoutePlanResponse.i;

data TaskTimingPair
end TaskTimingPair;

--Single task/vehicle timing information capturing the estimated time for the specified
--vehicle to travel to or between tasks
data implementation TaskTimingPair.i
	subcomponents
		--Corresponding Vehicle ID
		VehicleID: data int64.i;
		--Initial task ID (if zero, corresponds to current vehicle location)
		InitialTaskID: data int64.i;
		--Normalized progress along initial task (0.0 .. 1.0)
		InitialTaskPercentage: data real32.i;
		--Destination task ID
		DestinationTaskID: data int64.i;
		--Timing corresponding to travel between tasks. If time is less than zero, no feasible
		--path exists between tasks. If 'DestinationTaskID' is equal to 'InitialTaskID'
		--then 'TimeToGo' is the time to complete the task when performed by 'VehicleID'
		TimeToGo: data int64.i;
end TaskTimingPair.i;

data BatchSummaryRequest
end BatchSummaryRequest;

--Batch summary request whereby vehicle-to-task information is requested
data implementation BatchSummaryRequest.i
	subcomponents
		--Request ID for correlating with response
		RequestID: data int64.i;
		--An array of vehicles (by ID) to consider when planning
		Vehicles: data int64.i {Data_Model::Data_Representation => Array;};
		--List of task IDs to be planned to
		TaskList: data int64.i {Data_Model::Data_Representation => Array;};
		--string containing the relationship between requested tasks. If empty, all tasks
		--are to be completed in any order. The format of the string is specific to the
		--automation service. This relationship string is the mechanism for incorporating
		--task precedence, priority, timing, etc.
		TaskRelationships: data string.i;
		--List of task percentages along task to plan from
		InterTaskPercentage: data real32.i {Data_Model::Data_Representation => Array;};
		--Operating region to be considered during planning
		OperatingRegion: data int64.i;
end BatchSummaryRequest.i;

data BatchSummaryResponse
end BatchSummaryResponse;

--Batch summary response as a list of all vehicle-to-task information
data implementation BatchSummaryResponse.i
	subcomponents
		--Response ID matching request from ({@link BatchSummaryRequest})
		ResponseID: data int64.i;
		--Set of vehicle-to-task and task-to-task summaries including timing, communication,
		--and remaining energy
		Summaries: data TaskSummary.i {Data_Model::Data_Representation => Array;};
end BatchSummaryResponse.i;

data TaskSummary
end TaskSummary;

--Summary information that describes a particular way to carry out the task. In general,
--multiple task summaries for each task will be sent corresponding to each eligible
--vehicle completing the task. In the case where a task is completed by multiple
--vehicles simultaneously, then each TaskSummary will include the set of vehicles
--that would be used to complete the task.
data implementation TaskSummary.i
	subcomponents
		--ID of task in consideration
		TaskID: data int64.i;
		--Summary of information for each vehicle used simultaneously to complete this
		--task. If there are zero performing vehicles, then 'TaskID' cannot be completed
		--with any set of available vehicles in the system.
		PerformingVehicles: data VehicleSummary.i {Data_Model::Data_Representation => Array;};
		--Task cannot be completed as specified and is using best effort. Estimated percent
		--achieved while using best effort strategy.
		BestEffort: data real32.i;
end TaskSummary.i;

data VehicleSummary
end VehicleSummary;

--Single vehicle-to-task summary information
data implementation VehicleSummary.i
	subcomponents
		--ID of vehicle considered to complete 'DestinationTaskID'
		VehicleID: data int64.i;
		--ID of task for which 'VehicleID' is considered to perform
		DestinationTaskID: data int64.i;
		--ID of task from which 'VehicleID' is considered leave from. If zero, from current
		--position of vehicle
		InitialTaskID: data int64.i;
		--Percentage along initial task that vehicle should plan from
		InitialTaskPercentage: data real32.i;
		--Estimated time from start of task to task-percentage location
		EstimateTimeToTaskPercentage: data int64.i;
		--Travel time from the current vehicle location to the start of the task.
		TimeToArrive: data int64.i;
		--Time for this task to be completed by the specified vehicle
		TimeOnTask: data int64.i;
		--Energy remaining for vehicle after task has been completed, expressed in terms
		--of the percentage of maximum capacity
		EnergyRemaining: data real32.i;
		--Flag for indicating that the vehicle will leave communication range either enroute
		--or during the task
		BeyondCommRange: data bool.i;
		--Flag for indicating that the vehicle will conflict with ROZ enroute or during
		--the task
		ConflictsWithROZ: data bool.i;
		--IDs of ROZs that the vehicle will conflict with
		ROZIDs: data int64.i {Data_Model::Data_Representation => Array;};
		--The list of waypoints associated with this mission task. Waypoints are linked,
		--but the waypoint list may contain waypoints that are not necessarily linked.
		--Multiple linked routes may be sent in a single waypoint list. Waypoints are not
		--necessarily ordered in the list.
		WaypointList: data Waypoint.i {Data_Model::Data_Representation => Array;};
		--ID of the first waypoint in the plan.
		FirstWaypoint: data int64.i;
end VehicleSummary.i;

data ImpactHeartbeat
end ImpactHeartbeat;

--Component heartbeat expected to be sent out @ 1Hz
data implementation ImpactHeartbeat.i
	subcomponents
		--Label of system component sending heartbeat
		ComponentLabel: data string.i;
		--Time at which this heatbeat was sent (milliseconds since 1 Jan 1970 00:00 GMT)
		HeartbeatTime: data int64.i;
end ImpactHeartbeat.i;

data ImpactComponentJoin
end ImpactComponentJoin;

--Component Join
data implementation ImpactComponentJoin.i
	subcomponents
		--Label of component joining network
		ComponentLabel: data string.i;
end ImpactComponentJoin.i;

data ImpactComponentLeave
end ImpactComponentLeave;

--Component Leave
data implementation ImpactComponentLeave.i
	subcomponents
		--Label of component leaving network
		ComponentLabel: data string.i;
end ImpactComponentLeave.i;

data SpeedAltPair
end SpeedAltPair;

--Data structure for associating a vehicle to a particular altitude and speed
data implementation SpeedAltPair.i
	subcomponents
		--ID of vehicle for which altitude and speed is attached
		VehicleID: data int64.i;
		--ID of task for which altitude and speed is attached. If TaskID is zero, then
		--alt/speed setting applies to all tasks in the automation request
		TaskID: data int64.i;
		--The speed attached to this vehicle
		Speed: data real32.i;
		--Altitude attached to this vehicle
		Altitude: data real32.i;
		--Altitude type for specified altitude
		AltitudeType: data AltitudeType.i;
end SpeedAltPair.i;

data ImpactAutomationRequest
end ImpactAutomationRequest;

--Automation request specific to IMPACT (includes 'sandbox' feature and play/soln
--IDs)
data implementation ImpactAutomationRequest.i
	subcomponents
		--Request ID for correlating with response
		RequestID: data int64.i;
		--Standard CMASI Automation request. A valid ImpactAutomationRequest must define
		--TrialRequest (null not allowed).
		TrialRequest: data AutomationRequest.i;
		--Override nominal speed/alt. If a vehicle is not in list, its nominal speed/alt
		--is used
		OverridePlanningConditions: data SpeedAltPair.i {Data_Model::Data_Representation => Array;};
		--Associated play ID
		PlayID: data int64.i;
		--Associated solution ID
		SolutionID: data int64.i;
		--Flag indicating 'sandbox', i.e. not to be implemented
		Sandbox: data bool.i;
end ImpactAutomationRequest.i;

data ImpactAutomationResponse
end ImpactAutomationResponse;

--Automation response with specific IMPACT supporting fields
data implementation ImpactAutomationResponse.i
	subcomponents
		--Response ID matching request from ({@link ImpactAutomationRequest})
		ResponseID: data int64.i;
		--Automation response from the request. A valid ImpactAutomationResponse must define
		--TrialResponse (null not allowed).
		TrialResponse: data AutomationResponse.i;
		--Associated play ID
		PlayID: data int64.i;
		--Associated solution ID
		SolutionID: data int64.i;
		--Flag indicating 'sandbox', i.e. not to be implemented
		Sandbox: data bool.i;
		--Set of vehicle-to-task summaries that will be implemented by this automation
		--response. Including timing, communication, and remaining energy
		Summaries: data TaskSummary.i {Data_Model::Data_Representation => Array;};
end ImpactAutomationResponse.i;

data PointOfInterest
end PointOfInterest;

--Point of interest
data implementation PointOfInterest.i
	subcomponents
		--ID for points of interest
		PointID: data int64.i;
		--Point of interest location. A valid PointOfInterest must define Location (null
		--not allowed).
		Location: data Location3D.i;
		--Action that updated this point of interest (e.g. created, destroyed, modified)
		PointAction: data AreaActionOptions.i;
		--Human readable label for point of interest
		PointLabel: data string.i;
		--Background Behavior point is true if point is for background behavior
		BackgroundBehaviorPoint: data bool.i;
end PointOfInterest.i;

data LineOfInterest
end LineOfInterest;

--Line of interest
data implementation LineOfInterest.i
	subcomponents
		--ID for lines of interest
		LineID: data int64.i;
		--List of points to search
		Line: data Location3D.i {Data_Model::Data_Representation => Array;};
		--Action that updated this line of interest (e.g. created, destroyed, modified)
		LineAction: data AreaActionOptions.i;
		--Human readable label for line of interest
		LineLabel: data string.i;
		--Background Behavior line is true if point is for background behavior
		BackgroundBehaviorLine: data bool.i;
end LineOfInterest.i;

data AreaOfInterest
end AreaOfInterest;

--Area of interest
data implementation AreaOfInterest.i
	subcomponents
		--ID for area of interest
		AreaID: data int64.i;
		--Geometry describing the area. A valid AreaOfInterest must define Area (null not
		--allowed).
		Area: data AbstractGeometry.i;
		--Action that updated this area of interest (e.g. created, destroyed, modified)
		AreaAction: data AreaActionOptions.i;
		--Human readable label for area of interest
		AreaLabel: data string.i;
		--Background Behavior area is true if point is for background behavior
		BackgroundBehaviorArea: data bool.i;
end AreaOfInterest.i;

data ImpactPointSearchTask extends CMASI::SearchTask
end ImpactPointSearchTask;

--Impact Point Search Task
data implementation ImpactPointSearchTask.i extends CMASI::SearchTask.i
	subcomponents
		--Point to search (from available points of interest). Only valid if ID is non-zero
		SearchLocationID: data int64.i;
		--Defines coordinates directly, only used when SearchLocationID is non-zero
		SearchLocation: data Location3D.i;
		--Minimum distance that an aircraft must maintain from the point of interest.
		StandoffDistance: data real32.i;
		--A list of acceptable look-angles for this task. Each wedge is defined relative
		--to true North. To be a valid look angle, a sensor must be looking from a direction
		--within the bounds of the wedge.
		ViewAngleList: data Wedge.i {Data_Model::Data_Representation => Array;};
		--Loiter action to complete to fulfill task. If null, then simply points camera
		--but main trajectory does not change. Otherwise, completes the specified loiter
		--action.
		DesiredAction: data LoiterAction.i;
end ImpactPointSearchTask.i;

data PatternSearchTask extends CMASI::SearchTask
end PatternSearchTask;

--Search task with specified search pattern
data implementation PatternSearchTask.i extends CMASI::SearchTask.i
	subcomponents
		--Point at which to search is centered (from available points of interest)
		SearchLocationID: data int64.i;
		--Defines coordinates directly, only used when SearchLocationID is non-zero
		SearchLocation: data Location3D.i;
		--Search pattern to use
		Pattern: data AreaSearchPattern.i;
		--Pattern extent
		Extent: data real32.i;
end PatternSearchTask.i;

data AngledAreaSearchTask extends CMASI::SearchTask
end AngledAreaSearchTask;

--Area search task with specified direction
data implementation AngledAreaSearchTask.i extends CMASI::SearchTask.i
	subcomponents
		--Area to search (from available areas of interest)
		SearchAreaID: data int64.i;
		--Sweep angle defined from true North in clockwise manner
		SweepAngle: data real32.i;
		--Optional start point that must be reached before beginning search
		StartPoint: data Location3D.i;
end AngledAreaSearchTask.i;

data ImpactLineSearchTask extends CMASI::SearchTask
end ImpactLineSearchTask;

--Defines a line search task. A line search is a list of points that forms a polyline.
--The ViewAngleList determines from which direction the line may be viewed. View
--angles are specified using the {@link Wedge} type. If the UseInertialViewAngles
--option is true, then wedges are defined in terms of North-East coordinates, otherwise
--wedges are defined relative to the line segment currently being viewed (a vector
--from point i through point i+1). To be a valid look angle, the line segment must
--be viewed from an angle within the bounds of the wedge.
data implementation ImpactLineSearchTask.i extends CMASI::SearchTask.i
	subcomponents
		--ID of line to search (from available lines of interest)
		LineID: data int64.i;
		--Defines a list of acceptable look-angles for this task. See the documentation
		--above for details.
		ViewAngleList: data Wedge.i {Data_Model::Data_Representation => Array;};
		--If true, the ViewAngleList specifies inertial (North-East) angles. See documentation
		--above.
		UseInertialViewAngles: data bool.i;
end ImpactLineSearchTask.i;

data WatchTask extends CMASI::SearchTask
end WatchTask;

--Vehicle Watch task
data implementation WatchTask.i extends CMASI::SearchTask.i
	subcomponents
		--Entity ID to follow and watch
		WatchedEntityID: data int64.i;
end WatchTask.i;

data MultiVehicleWatchTask extends CMASI::SearchTask
end MultiVehicleWatchTask;

--Multi vehicle overwatch task
data implementation MultiVehicleWatchTask.i extends CMASI::SearchTask.i
	subcomponents
		--Entity ID to follow and watch
		WatchedEntityID: data int64.i;
		--Number of vehicles to simultaneously overwatch the target
		NumberVehicles: data byte.i;
end MultiVehicleWatchTask.i;

data CommRelayTask extends CMASI::Task
end CommRelayTask;

--Task for providing comm relay support
data implementation CommRelayTask.i extends CMASI::Task.i
	subcomponents
		--ID of entity which requires comm relay support
		SupportedEntityID: data int64.i;
		--Destination location for supported entity, if known.
		DestinationLocation: data Location3D.i;
		--ID of entity to which communication will be delivered (i.e. Tower ID)
		TowerID: data int64.i;
end CommRelayTask.i;

data CordonTask extends CMASI::Task
end CordonTask;

--Task for using multiple ground vehicles to block access to an area. Given a point
--to secure and a standoff distance, task identifies number (K) routes that must
--be blocked to successfully deny access to the area. If there are not enough eligible
--vehicles, then this task will use the maximum number of eligible vehicles in a
--best effort strategy which attempts to maximize radial coverage.
data implementation CordonTask.i extends CMASI::Task.i
	subcomponents
		--Block road access to this location. A valid CordonTask must define CordonLocation
		--(null not allowed)
		CordonLocation: data Location3D.i;
		--Distance away from 'CordonLocation' that access should be blocked
		StandoffDistance: data real32.i;
end CordonTask.i;

data BlockadeTask extends CMASI::Task
end BlockadeTask;

--Task for using multiple vehicles to surround an entity, for example, multiple surface
--vehicles surrounding incoming enemy ship.
data implementation BlockadeTask.i extends CMASI::Task.i
	subcomponents
		--Entity to surround and deny access
		BlockedEntityID: data int64.i;
		--When in blocking formation, the distance that vehicles should stand off.
		StandoffDistance: data real32.i;
		--Number of vehicles to simultaneously block the target
		NumberVehicles: data byte.i;
		--Biases the blockade so that more vehicles are between enemy and protected location.
		--If null location is given, then blockade attempts to block in direction of enemy
		--travel
		ProtectedLocation: data Location3D.i;
end BlockadeTask.i;

data EscortTask extends CMASI::SearchTask
end EscortTask;

--Task for targeting surveillance at an offset of a moving entity, for example to
--scout ahead of a convoy.
data implementation EscortTask.i extends CMASI::SearchTask.i
	subcomponents
		--ID of entity which will provide the basis for the escort. Tasked vehicle will
		--attempt to stay 'StandoffDistance' ahead of this entity on its route.
		SupportedEntityID: data int64.i;
		--ID of line which describes the route that the 'SupportedEntityID' is following.
		--If the 'SupportedEntityID' is one of the controlled entities, such as a taskable
		--ground vehicle, then 'RouteID' can be zero and this task will use current, known
		--route for that vehicle. Otherwise, 'RouteID' must be an ID for a previously described
		--'{@link LineOfInterest}'.
		RouteID: data int64.i;
		--Waypoints that the supported entity is presumed to be following if 'RouteID'
		--is zero
		PrescribedWaypoints: data Waypoint.i {Data_Model::Data_Representation => Array;};
		--Distance ahead (positive) or behind (negative) that the vehicle will provide
		--surveillance relative to 'SupportedEntityID's location on route 'RouteID'
		StandoffDistance: data real32.i;
end EscortTask.i;

data ConfigurationRequest
end ConfigurationRequest;

--Requests the latest configurations for vehicles in the system
data implementation ConfigurationRequest.i
	subcomponents
		--Vehicle IDs for which the corresponding configuration should be sent. If the
		--list is empty, all available configurations should be sent in response.
		VehicleID: data int64.i {Data_Model::Data_Representation => Array;};
end ConfigurationRequest.i;

data WaterReport
end WaterReport;

--Reports on navigability of the water in the "Area". Based on the WeatherReport
--CMASI message, designed to allow changes during execution.
data implementation WaterReport.i
	subcomponents
		--Area for which this report is valid. A valid WaterReport must define Area (null
		--not allowed)
		Area: data AbstractGeometry.i;
		--Speed of the current, e.g. due to tides or river flow
		CurrentSpeed: data real32.i;
		--Direction of the current
		CurrentDirection: data real32.i;
		--Wave direction of travel. Generally in the direction of the wind, except near
		--sea coasts
		WaveDirection: data real32.i;
		--Average wave height
		WaveHeight: data real32.i;
end WaterReport.i;

data WaterZone extends CMASI::AbstractZone
end WaterZone;

--Region that defines water areas navigable for surface vehicles. Ground vehicles
--should not enter this zone.
data implementation WaterZone.i extends CMASI::AbstractZone.i
end WaterZone.i;


