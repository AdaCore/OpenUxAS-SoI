fsm_abstraction_rev2: THEORY
BEGIN

IMPORTING fsm_abstraction_rev2_FiniteStateMachine;

  %|- *_TCC* : PROOF
  %|-   (skeep 1 t)(model-check)
  %|- QED

  %|- *int*_TCC* : PROOF
  %|-   (skeep 1 t)(grind)
  %|- QED

% Type of state

state_type: TYPE = [#
                     f_FiniteStateMachine_sys: fsm_abstraction_rev2_FiniteStateMachine.sys_type
                    #];

% Type of output

out_type: TYPE = [#
                   f_STATE: real
                  #];

% Type of system state

sys_type: TYPE = [#
                   f_state: state_type,
                   f_output: out_type
                  #];

STATE(p_FiniteStateMachine: real): real =
  p_FiniteStateMachine;

% Initialize state
prepare_state(p_FiniteStateMachine_sys: fsm_abstraction_rev2_FiniteStateMachine.sys_type): state_type =
  (#
    f_FiniteStateMachine_sys := p_FiniteStateMachine_sys
   #);

% Initialize output
prepare_output(p_STATE: real): out_type =
  (#
    f_STATE := p_STATE
   #);

% Initialize system state
init: sys_type =
  (#
    f_state := prepare_state(fsm_abstraction_rev2_FiniteStateMachine.init),
    f_output := prepare_output(0)
   #);

% Whole system run, this can only be called after INIT and inputs setting
run(p_sys: sys_type, p_fails: Demux_bustype): sys_type =
  LET v_FiniteStateMachine_sys: fsm_abstraction_rev2_FiniteStateMachine.sys_type = 
    fsm_abstraction_rev2_FiniteStateMachine.run(p_sys`f_state`f_FiniteStateMachine_sys, p_fails) IN
  LET v_STATE: real = STATE(v_FiniteStateMachine_sys`f_output`f_STATE) IN
  (#
    f_state := prepare_state(v_FiniteStateMachine_sys),
    f_output := prepare_output(v_STATE)
   #);

END fsm_abstraction_rev2
