package UxAS_responds_pkg
public
	--Included DataTypes
    with CMASI;
    with UXTASK;
    
    -- Included Main Services
	with AutomationRequestValidatorService_Pkg;	
    
    process UxAS_responds
    	features
    		AutomationRequest_in: in event data port CMASI::AutomationRequest.i;
    		AutomationResponse_out: out event data port cmasi::AutomationResponse.i;
    	annex agree {**
    		assume "Process one automation request at a time" :
        		pre(PLTL.Once(event(AutomationRequest_in))) => not event(AutomationRequest_in);

    		guarantee "(Timing not realistic.) When an AutomationRequest_in is received by UxAS, 
    			UxAS responds with an AutomationResponse_out on the next timestep.":
    			(prev(event(AutomationRequest_in), false) => event(AutomationResponse_out));
    		
    		---------------------------------
    		--DRAFT STUFF FOR TWO TIMESTEPS (NOT THERE YET)
    		--eq TIME_BOUND : int = 2;
    		
    		--Use responds or responds within. Do we have something like that in SpeAR now? Maybe I should try
    		-- it out there first.
    		--guarantee ""
    		
--    		guarantee "(Timing not realistic.) When an AutomationRequest_in is received by UxAS, 
--    			UxAS responds with an AutomationResponse_out within two timesteps.":
--    			(prev(prev(event(AutomationRequest_in), false), false) => event(AutomationResponse_out));
			---------------------------------
    	**};
    end UxAS_responds;
    
    process implementation UxAS_responds.i
    	subcomponents
    		 AutomationRequestValidatorService: thread AutomationRequestValidatorService_Pkg::AutomationRequestValidatorService;
    	connections
    		conn001: port AutomationRequest_in -> AutomationRequestValidatorService.AutomationRequest_in;
    		conn002: port AutomationRequestValidatorService.AutomationResponse_out -> AutomationResponse_out;
    	annex agree {**
    		lemma "Observe event(AutomationResponse_out)": 
    			not event(AutomationResponse_out);
    	**};
    end UxAS_responds.i;
    
end UxAS_responds_pkg;