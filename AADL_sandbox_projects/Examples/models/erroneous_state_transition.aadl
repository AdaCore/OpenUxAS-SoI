package erroneous_state_transition
public
	with Base_Types;
	
	-- This is a "dummy" top-level system. We use it so that we can check 
	--  "properties" of our component contract.
	system top_level
		annex agree {**
			guarantee "Placeholder guarantee to force AGREE to run" : true;
		**};
	end top_level;
	
	system implementation top_level.Impl
		subcomponents
			sub : system example; 
		annex agree {**
			------------------------------------------------------
			-- These lemmas could be captured in SpeAR as properties
			
			--State machine lemmas
			lemma "The value of the state variable corresponds to a 'real' state." :
				(sub.state = sub.STATE1) 
				or (sub.state = sub.STATE2);
				
			lemma "Only stated transitions are allowed." :
				sub.some_transition or (sub.state = sub.state);
			------------------------------------------------------
			-- These lemmas could be captured in SpeAR as observers (without the negation)
			
			--Check that all states are reachable
			lemma "False indicates State1 reachable" : not (sub.state = sub.STATE1);
			lemma "False indicates State2 reachable" : not (sub.state = sub.STATE2);
			
			--Check that all state transitions are reachable
			lemma "False indicates that one_to_two is reachable" : not sub.one_to_two;

			lemma "True if only stated transitions are executed (no missing transitions)." :
                sub.some_transition or sub.state = sub.previous_state;	
            
            --Check if there is an error in how outputs trigger state transitions.     
            
            ---- The following two lemmas, if both true at the same time or both false indicates an error ----
            lemma "True (falling edge) indicates a state change has already occurred if the output_condition occurs" :
            	sub.state1_output_condition =>
            		(true -> (sub.state != pre(sub.state)));
            		
            lemma "True (rising edge) indicates a state change occurs after an output_condition" :
            	pre(sub.state1_output_condition) =>
            		(true -> sub.state != pre(sub.state));
            -------------
            
            ---- Sanity check on the above two lemmas ----
            
            lemma "False (falling edge witness)" :
            	sub.state1_output_condition =>
            		(true -> (sub.state = pre(sub.state)));
            		
            lemma "False (rising edge witness)" :
            	pre(sub.state1_output_condition) =>
            		(true -> sub.state = pre(sub.state));
            -------------
            
            
            ---Jen's Lemmas	
            lemma "Output event in state 1 => transition" :
                pre(event(sub.output)) and (true -> (pre(sub.state) = sub.STATE1))
                    => (sub.state = sub.STATE2);		
            
            lemma "Output event => transition with exceptions" :
                true -> (pre(event(sub.output)) =>
                            (sub.some_transition or
                            (sub.state = sub.STATE2))); -- STATE2 is the terminal state.
            	
		**};
		 
	end top_level.Impl;	
	
	
	system example
		features
			input: in event data port Base_Types::integer;
			output: out event data port Base_Types::integer;
			
		annex agree{**
			const STATE1 : int = 0;
            const STATE2 : int = 1;

            eq state : int;
            eq previous_state: int = prev(state,STATE1);
            eq some_transition: bool = one_to_two;
            
            eq state1_output_condition : bool = (false ->
            	(state = STATE1 and event(input)));
            
            eq state2_output_condition : bool = (false ->
            	(state = STATE2 and event(input)));
            
            eq all_output_conditions : bool = (false ->
            	((state1_output_condition)
            --CHALLENGE TO ERROR DETECTION IDIOM (discussed below):
            	--predicate after 'or' would make the example erroneous again,
            	--undetectable even with the proposed fix. 
            	or
            	(state2_output_condition)));
                
            --EXAMPLE SPEC ERROR:
            	--The error below cannot be found with the current lemmas.
            	--The correction (patch) below is what should have been written (using 'pre').                    
            eq one_to_two : bool = (false->
            	--SPEC ERROR
                previous_state = STATE1 and event(output));
                --CORRECTED SPEC (patch)
--                (previous_state = STATE1 and pre(event(output))));
                    
            guarantee "Self loops": not some_transition => (state = previous_state);
            
            guarantee "Transition from 1 to 2":
                one_to_two =>
                    state = STATE2;
       
            guarantee "Send output when an input is received in STATE 1":
            	 state1_output_condition =>
            	 	event(output);
 	
           	guarantee "Send output when an input is received in STATE 2":
            	 state2_output_condition =>
            	 	event(output);
            	
            --Suggested Problem Fix (ERROR DETECTION IDIOM)
            	-- Further specification about when an output event can and cannot occur
            	-- (using iff to indicate it only occurs under the specific output predicates)
            	-- Provides further spec definition to catch the above error
            	-- as a realizability failure. 
            --Challenge/Issue with the fix (CHALLENGE TO ERROR DETECTION)
           		-- If output_condition overlaps with any state transitions, 
           		-- the error becomes undetectable again.
           		-- e.g., output_condition includes `state = STATE2 and event(input)
           		-- in this case, event(output) can occur in STATE2 immediately on state entry. 
            guarantee "PROBLEM FIX: Define the event(output) in all other cases" :
            	all_output_conditions <=> 
            		event(output);
		**};
		
	end example;
end erroneous_state_transition;