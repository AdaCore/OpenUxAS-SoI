package inadvertent_output_constraint
public
	with Base_Types;
	
	-- This is a "dummy" top-level system. We use it so that we can check 
	--  "properties" of our component contract.
	process top_level
		annex agree {**
			guarantee "Placeholder guarantee to force AGREE to run" : true;
		**};
	end top_level;
	
	process implementation top_level.Impl
		subcomponents
			sub : thread TaskServiceBase; 
		annex agree {**
			------------------------------------------------------
			-- These lemmas could be captured in SpeAR as properties
			
			--State machine lemmas
			lemma "(True expected) The value of the state variable corresponds to a 'real' state." :
				(sub.state = sub.STATE1) 
				or (sub.state = sub.STATE2);
				
			lemma "(TRUE expected) Only stated transitions are allowed." :
				sub.some_transition or (sub.state = sub.previous_state);
			------------------------------------------------------
			-- These lemmas could be captured in SpeAR as observers (without the negation)
			
			--Check that all states are reachable
			lemma "(FALSE expected) indicates State1 reachable" : not (sub.state = sub.STATE1);
			lemma "(FALSE expected) indicates State2 reachable" : not (sub.state = sub.STATE2);
				
			--Check that all state transitions are reachable
			lemma "(FALSE expected) indicates that one_to_two is reachable" : not sub.one_to_two;
			lemma "(FALSE expected) indicates that two_to_one is reachable": not sub.two_to_one;
			
			-- Misc. Example Checks if the output_var can be more than one value
			
			lemma "(FALSE expected) Test1: output constant in all states" :
				true -> (sub.output = pre(sub.output));
				
			lemma "(FALSE expected) Test2: out_var constant in all states" :
				true -> (sub.out_var = pre(sub.out_var));	
				
			lemma "(FALSE expected) Test2a: out_var constant in all states" :
				true -> 
					((sub.state = sub.STATE1 => sub.out_var = pre(sub.out_var)) and
					(sub.state = sub.STATE2 => sub.out_var = pre(sub.out_var)));
					
			lemma "(FALSE expected) Test 3: out_var constant in some or all states" : 
				true -> 
					((sub.state = sub.STATE1 or sub.state = sub.STATE2) => sub.out_var = pre(sub.out_var));
			
			lemma "(FALSE expected) Test4: out_var constant always in STATE1":
				true -> (sub.state = sub.STATE1 => sub.out_var = pre(sub.out_var)); 
				
			lemma "(FALSE expected)Test5: out_var constant always in STATE2":
				true -> (sub.state = sub.STATE2 => sub.out_var = pre(sub.out_var));
				
			
			lemma "(FALSE expected) Test6a: out_var constant at all assignments (transitions)" : 
				true -> 
					((sub.one_to_two => sub.out_var = pre(sub.out_var)) and
					(sub.two_to_one => sub.out_var = pre(sub.out_var)));
					
			lemma "(TRUE expected) Test6b: non constant out_var implies an output (assingment) condition ":
				true ->
					((sub.out_var != pre(sub.out_var)) => sub.some_transition);

			--NOTE: while it is possible to detect the variable is non-constant, it is more problematic
			--if the output can be constrained abitrarily. I do not believe AGREE can generally catch 
			--output constraints. Lemma "tests" can be developed but this is merely testing of the model, not a proof. 
		
		**};
		 
	end top_level.Impl;	
	
	
	
    thread TaskServiceBase
    	features
    		output: out event data port Base_Types::Integer;
       	annex agree{**
       		eq state : int;

       		eq out_var : int;
       		
       		eq free_int : int;
       		
       		--Task States
       		const STATE1 : 			int = 1;
       		const STATE2 : 			int = 2;
       		
       	-------------------------------------------------------------
		--State machine support macros
			eq previous_state: int = prev(state,STATE1);
			eq some_transition: bool = one_to_two
									or two_to_one;

		-------------------------------------------------------------		
	
		--------------------------State Transition Predicates-----------------------------------	
			eq one_to_two : bool = (false->
				(previous_state = STATE1 and event(output)));
				
			eq two_to_one : bool = (false ->
				(previous_state = STATE2 and event(output)));
       			
       		guarantee "Self loops": (not some_transition => (state = previous_state));
       			
       		--Note: this mechanism of state transitions was applied 
       		--to maintain the state of a variable in all states once assigned.
       		--The risk of this approach is that if there is more than one assignment of the
       		--variable possible, as is the case in this example. This mistake is not caught
       		--by any analysis. 
       		
       		-- Problem Example 1 --
       		-- Both guarantees specify out_var does not change unless in the specific transition
   			guarantee "State 1 to 2" :
   			if one_to_two then
   				state = STATE2 and
   				out_var = output
   			else
   				out_var = pre(out_var);				
   				
   			guarantee "State 2 to 1" :
   			if two_to_one then
   				state = STATE1 and
   				out_var = output
   			else
   				out_var = pre(out_var);
   				
--   			-- Problem Example 2 --
--   			-- Only two_to_one transition specifies that out_var does not change unless in its specific transition
--   			guarantee "State 1 to 2" :
--   			if one_to_two then
--   				state = STATE2 and
--   				out_var = output
--   			else
--   				out_var = pre(out_var);	
--   				
--   			guarantee "State 2 to 1" :
--   			two_to_one =>
--   				state = STATE1 and
--   				out_var = output;
   			
--   			-- Problem Example 3 --
--   			-- Only two_to_one transition specifies that out_var does not change unless in its specific transition
--   			guarantee "State 1 to 2" :
--   			one_to_two =>
--   				state = STATE2 and
--   				out_var = output;
--   				
--   			guarantee "State 2 to 1" :
--   			if two_to_one then
--   				state = STATE1 and
--   				out_var = output
--   			else
--   				out_var = pre(out_var);
--   				
--   			--- Proposed Solution Idiom Below ---
--   			
--   			guarantee "If not transitioning, the out_var should not change" :
--   				true -> 
--   				((not one_to_two and not two_to_one) =>
--   					(out_var = pre(out_var)));
--   					
--   			guarantee "State 1 to 2" :
--   			one_to_two =>
--   				state = STATE2 and
--   				out_var = output;
--   				
--   			guarantee "State 2 to 1" :
--   			two_to_one =>
--   				state = STATE1 and
--   				out_var = output;

   
       	**};
       	
    end TaskServiceBase;
    
end inadvertent_output_constraint;