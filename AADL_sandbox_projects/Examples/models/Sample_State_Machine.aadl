-- Authors: Rockwell Collins and Dependable Computing
-----------------------------------------------------
-- The state machine this implements looks like this:
--   A->B->C
--   |     ^
--   |_____|
------------------------------------------------------

package Sample_State_Machine

public
	with Base_Types;
	
	-- This is a "dummy" top-level system. We use it so that we can check 
	--  "properties" of our component contract.
	system top_level
		annex agree {**
			guarantee "Placeholder guarantee to force AGREE to run" : true;
		**};
	end top_level;
	
	system implementation top_level.Impl
		subcomponents
			sub : system Sample_State_Machine_Sys; 
		annex agree {**
			------------------------------------------------------
			-- These lemmas could be captured in SpeAR as properties
			
			--State machine lemmas
			lemma "The value of the state variable corresponds to a 'real' state." :
				(sub.State_out = sub.StateA) 
				or (sub.State_out = sub.StateB)
				or (sub.State_out = sub.StateC);
				
			lemma "Only stated transitions are allowed." :
				sub.some_transition or (sub.State_out = sub.previous_state);
			------------------------------------------------------
			-- These lemmas could be captured in SpeAR as observers (without the negation)
			
			--Check that all states are reachable
			lemma "False indicates StateA reachable" : not (sub.State_out = sub.StateA);
			lemma "False indicates StateB reachable" : not (sub.State_out = sub.StateB);
			lemma "False indicates StateC reachable" : not (sub.State_out = sub.StateC); 
			
			--Check that all state transitions are reachable
			lemma "False indicates that T_A_to_B is reachable" : not sub.T_A_to_B;
			lemma "False indicates that T_B_to_C is reachable": not sub.T_B_to_C;
			lemma "False indicates that T_A_to_C is reachable": not sub.T_A_to_C;
		**};
		 
	end top_level.Impl;	

system Sample_State_Machine_Sys
	features
      	Go_To_Next_State_in: in data port Base_Types::Boolean;
      	Skip_Enabled_in : in data port Base_Types::Boolean;
      	State_out: out data port Base_Types::Integer;
		
	annex agree {**
		const StateA : int = 0;
        const StateB : int = 1;
        const StateC : int = 2;
		
		-------------------------------------------------------------
		--State machine support macros
		eq previous_state: int = prev(State_out, StateA);
		eq some_transition: bool = T_A_to_B
									or T_B_to_C
									or T_A_to_C;

		-------------------------------------------------------------		
		--State transition macros
		
		--This is initially false to prevent transition to B on the initial timestep
		eq T_A_to_B : bool = 
			false -> ((previous_state = StateA) and Go_To_Next_State_in) and not Skip_Enabled_in;
	
		-- The following would be an easy mistake to make. To see how realizability catches the problem,
		--  comment out T_A_to_B above, uncomment T_A_to_B below, and run realizability (on the system). 
		--  You should see a counterexample.
--		eq T_A_to_B : bool = 
--			false -> ((previous_state = StateA) and Go_To_Next_State_in);
	
		eq T_B_to_C : bool = 
			(previous_state = StateB) and Go_To_Next_State_in;
		
		--This is initially false to prevent transition to B on the initial timestep	
		eq T_A_to_C : bool = 
			false -> ((previous_state = StateA) and Go_To_Next_State_in and Skip_Enabled_in);

		-------------------------------------------------------------	
		--State machine guarantees
				
		-- Note: The state machine is represented by guarantees, which AGREE will assume to be 
		-- true since this is the lowest level component.  Guarantees (or lemmas) about this 
		-- state machine would be stated and proved at the next level up.  This idiom allows us to 
		-- state the transitions individually, without complex if/then/else nests that would 
		-- result if we attempted to model the state machine in imperative style; 
		-- these nests would become progressively more difficult to maintain as the 
		-- state machine became more complex (more states and/or transitions).
		-- Additionally, a more "declarative" style is more natural for architectural 
		-- level modeling.
		-- The only "tricky" part is to ensure that all transitions are encoded.
		
		--This guarantee specifies the initial state.
        guarantee "Initial_State": (State_out = StateA) -> true;
        
        --This guarantee captures all the "self loops" in shorthand form. 
        -- It is important to state what happens when no transition condition is satisfied.
        -- Otherwise the model checker will allow "spontaneous" transitions.
        guarantee "Self loops": not some_transition => (State_out = previous_state);
        
        -- Now we write one guarantee for each transition.
        
        --If we had other actions to take on this transition, we would include those in the consequent as well. 
        guarantee "T_A_to_B_effect" : T_A_to_B => (State_out = StateB);
       
        guarantee "T_B_to_C_effect" : T_B_to_C => (State_out = StateC);
               
        guarantee "T_A_to_C_effect" : T_A_to_C => (State_out = StateC);                       
                     
		**};
		
	end Sample_State_Machine_Sys;

end Sample_State_Machine;