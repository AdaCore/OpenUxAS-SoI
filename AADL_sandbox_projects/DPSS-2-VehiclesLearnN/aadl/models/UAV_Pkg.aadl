package UAV_Pkg
public
	with DPSS_Data_Types;
	with Base_Types;
	with DPSS_Constants;
	 
	system UAV
		features
			--Inputs
			suggested_initial_direction : in data port DPSS_Data_Types::Direction_Type; --The UAV may choose a different direction for the initial timestep, depending on the circumstances.
			initial_position : in data port DPSS_Data_Types::Position_Type;
			meet_LN : in data port Base_Types::Boolean; --True iff this UAV and its left neighbor are co-located
			meet_RN : in data port Base_Types::Boolean; --True iff this UAV and its right neighbor are co-located		
--			perimRight_RN : in data port DPSS_Data_Types::Distance_Type; --Perimeter to the right of the right neighbor (as best as the right neighbor knows it) 
--			perimLeft_LN : in data port DPSS_Data_Types::Distance_Type; --Perimeter to the left of the left neighbor (not necessary because this is equal to pos_LN)
			numRight_RN : in data port Base_Types::Float;
			numLeft_LN : in data port Base_Types::Float;
--			right_endp_truth : in data port DPSS_Data_Types::Distance_Type; --only used to detect when the UAV reaches the true right endpoint
--			left_endp_truth : in data port DPSS_Data_Types::Distance_Type; --only used to detect when the UAV reaches the true left endpoint
--			id : in data port Base_Types::Float; --a positive integer between 1 and N
			pos : in data port DPSS_Data_Types::Position_Type;
			
			--Outputs
			direction: out data port DPSS_Data_Types::Direction_Type;
			goal : out data port DPSS_Data_Types::Position_Type;
--			perimRight : out data port DPSS_Data_Types::Distance_Type; --perimeter to the right of this UAV (as best as it knows)
--			perimLeft : out data port DPSS_Data_Types::Distance_Type; --perimeter to the left of this UAV (as best as it knows)
			numRight : out data port Base_Types::Float; --number of UAVs to the right of this UAV (as best as this UAV knows)
			numLeft : out data port Base_Types::Float; --number of UAVs to the left of this UAV (as best as this UAV knows)		
					
		annex agree {**
			
			-----------------------------------------------------
			--STATE VARIABLES
			-----------------------------------------------------
	
			eq reach_right_endp_truth : bool = (pos >= DPSS_Constants.RIGHT_ENDP_TRUTH); 
			eq reach_left_endp_truth : 	bool = (pos <= DPSS_Constants.LEFT_ENDP_TRUTH); 

			--Previous numLeft
			eq pre_numLeft : real = prev(numLeft, 0.0);
			
			--Previous numRight
			eq pre_numRight : real = prev(numRight, 0.0);
			
--			--Previous perimRight
--			eq pre_perimRight : real = prev(perimRight, 0.0);
--
--			--Previous preimLeft
--			eq pre_perimLeft : real = prev(perimLeft, 0.0);			
			
			--ID (will change during execution as this UAV meets its neighbors)
			eq id : real = numLeft + 1.0;
			
			--Total number of UAVs (as best as this UAV knows)
			eq N : real = numLeft + numRight + 1.0;
			
--			--Total perimeter (as best as this UAV knows)
--			eq P : DPSS_Data_Types::Position_Type = 
--				perimRight + perimLeft;
--				
--			eq left_endp_est : DPSS_Data_Types::Position_Type = 
--				pos - perimLeft;
--				
--			eq right_endp_est : DPSS_Data_Types::Position_Type = 
--				pos + perimRight;
				
			--Shared border positions
--			eq S_L : DPSS_Data_Types::Position_Type = 
--				(id - 1.0)*DPSS_Constants.P_TRUTH/N + DPSS_Constants.LEFT_ENDP_TRUTH;  
--			eq S_R : DPSS_Data_Types::Position_Type = 
--				id*DPSS_Constants.P_TRUTH/N + DPSS_Constants.LEFT_ENDP_TRUTH;	
			
			--Shared border positions -- LINEARIZED. ASSUMES N <= 7.
			eq S_L : DPSS_Data_Types::Position_Type =
				if N = 1.0 then 
					(id - 1.0)*DPSS_Constants.P_TRUTH/1.0 + DPSS_Constants.LEFT_ENDP_TRUTH
				else 
					if N = 2.0 then 
						(id - 1.0)*DPSS_Constants.P_TRUTH/2.0 + DPSS_Constants.LEFT_ENDP_TRUTH
					else
						if N = 3.0 then 
							(id - 1.0)*DPSS_Constants.P_TRUTH/3.0 + DPSS_Constants.LEFT_ENDP_TRUTH
						else
							if N = 4.0 then 
								(id - 1.0)*DPSS_Constants.P_TRUTH/4.0 + DPSS_Constants.LEFT_ENDP_TRUTH
						 	else 
						 		if N = 5.0 then 
									(id - 1.0)*DPSS_Constants.P_TRUTH/5.0 + DPSS_Constants.LEFT_ENDP_TRUTH
								else 
									if N = 6.0 then 
										(id - 1.0)*DPSS_Constants.P_TRUTH/6.0 + DPSS_Constants.LEFT_ENDP_TRUTH
									else --N >= 7.0
										(id - 1.0)*DPSS_Constants.P_TRUTH/7.0 + DPSS_Constants.LEFT_ENDP_TRUTH;
			
			eq S_R : DPSS_Data_Types::Position_Type =
				if N = 1.0 then 
					id*DPSS_Constants.P_TRUTH/1.0 + DPSS_Constants.LEFT_ENDP_TRUTH
				else 
					if N = 2.0 then 
						id*DPSS_Constants.P_TRUTH/2.0 + DPSS_Constants.LEFT_ENDP_TRUTH
					else
						if N = 3.0 then 
							id*DPSS_Constants.P_TRUTH/3.0 + DPSS_Constants.LEFT_ENDP_TRUTH
						else
							if N = 4.0 then 
								id*DPSS_Constants.P_TRUTH/4.0 + DPSS_Constants.LEFT_ENDP_TRUTH
						 	else 
						 		if N = 5.0 then 
									id*DPSS_Constants.P_TRUTH/5.0 + DPSS_Constants.LEFT_ENDP_TRUTH
								else 
									if N = 6.0 then 
										id*DPSS_Constants.P_TRUTH/6.0 + DPSS_Constants.LEFT_ENDP_TRUTH
									else --N >= 7.0
										id*DPSS_Constants.P_TRUTH/7.0 + DPSS_Constants.LEFT_ENDP_TRUTH;	  
						
			--Previous direction
			eq pre_direction : DPSS_Data_Types::Direction_Type = 
				prev(direction, suggested_initial_direction);
				
			--Previous position
			eq pre_pos : DPSS_Data_Types::Position_Type =
				prev(pos, initial_position);
						
			-----------------------------------------------------
			--ASSUMPTIONS
			-----------------------------------------------------		
			
--			assume "ID in range":
--				id >= 1.0 and id <= DPSS_Constants.N_real;
--						
--			assume "ID is fixed":
--				true -> (id = pre(id));

--			assume "right_endp_truth is greater than left_endp_truth":
--				right_endp_truth > left_endp_truth;
--				
--			assume "right_endp_truth is fixed":
--				true -> (right_endp_truth = pre(right_endp_truth));
--
--			assume "left_endp_truth is fixed":
--				true -> (left_endp_truth = pre(left_endp_truth));			
						
			assume "Suggested initial direction is LEFT or RIGHT":
				(	   suggested_initial_direction = DPSS_Constants.LEFT
					or suggested_initial_direction = DPSS_Constants.RIGHT)
				-> true;
			
--			assume "perimRight_RN is nonnegative":
--				meet_RN => (perimRight_RN >= 0.0);	
--			
--			assume "perimLeft_LN is nonnegative":
--				meet_LN => (perimLeft_LN >= 0.0);	
			
			-----------------------------------------------------
			--GUARANTEES
			-----------------------------------------------------
	
			guarantee "Direction formula":
				direction = (
					-- Turn around at the left boundary.
					if reach_left_endp_truth then
						1
					else 
						-- Turn around at the right boundary.
						if reach_right_endp_truth then
							-1
						else 
							-- If meeting left neighbor, travel together toward shared border.
							if meet_LN then
								if pos <= S_L then
									1
								else --pos > S_L
									-1
							else
								-- If meeting right neighbor, travel together toward shared border. 
							  	if meet_RN then
									if pos < S_R then
										1
									else --pos >= S_R
										-1 
								-- In all other cases, proceed in the same direction.
								else 
									pre_direction
				);  

			guarantee "Goal formula":
				goal = (
						-- If co-located with left and right neighbors,...
						if meet_LN and meet_RN then
							--...and at or to the left of the shared border with the left neighbor, make goal the shared border with the right neighbor.
							if pos <= S_L then
								S_R
							--...and to the right of the shared border with the left neighbor, make goal the shared border with the left neighbor.
							else -- pos > S_L
								S_L 
						else		
							-- If co-located with left neighbor only,...
							if meet_LN then
								--...and at or to the left of the shared border with the left neighbor, make goal the right endpoint.
								if pos <= S_L then
									DPSS_Constants.RIGHT_ENDP_TRUTH
								--...and to the right of the shared border with the left neighbor, make goal the shared border with the left neighbor.
								else -- pos > S_L
									S_L
							else 
								-- If co-located with right neighbor only,...
								if meet_RN then
									--...and at or to the right of the shared border with the right neighbor, make goal the left endpoint.
									if pos >= S_R then
										DPSS_Constants.LEFT_ENDP_TRUTH
									--...and to the left of the shared border with the right neighbor, make goal the shared border with the right neighbor.
									else -- pos < S_R
										S_R
								else -- If not co-located with either neighbor,...
									-- ...and heading right, set goal to the right endpoint. 
									if direction = 1 then
										DPSS_Constants.RIGHT_ENDP_TRUTH
									  -- ...and heading left, set goal to the left endpoint.
									else --direction = -1 
										DPSS_Constants.LEFT_ENDP_TRUTH 
				); 
						
		
			guarantee "numLeft formula":
				numLeft = if meet_LN then numLeft_LN + 1.0 else pre_numLeft;
				
			guarantee "numRight formula":
				numRight = if meet_RN then numRight_RN + 1.0 else pre_numRight;
			
--			guarantee "perimRight formula":
--				perimRight = if meet_RN then 
--								perimRight_RN 
--							 else 
--							 	if reach_right_endp_truth then
--							 		0.0
--							 	else  
--								 	if pre_direction = 1 then
--								 		pre_perimRight - (pos - pre_pos)
--								 	else --pre_direction = -1
--								 		pre_perimRight + (pre_pos - pos);
--								 		
--			guarantee "perimLeft formula":
--				perimLeft = if meet_LN then
--								perimLeft_LN
--							else 
--								if reach_left_endp_truth then
--									0.0
--								else
--									if pre_direction = 1 then
--										pre_perimLeft + (pos - pre_pos)
--									else --pre_direction = -1
--										pre_perimLeft - (pre_pos - pos);
			
--This should be a lemma in the higher level
--			guarantee "ID in range":
--				id >= 1 and id <= N;
			
		**};
		
	end UAV;
end UAV_Pkg;