package UAV_Pkg
public
	with DPSS_Data_Types;
	with Base_Types;
	with DPSS_Constants;
	 
	system UAV
		features
			--Inputs
			suggested_initial_direction : in data port DPSS_Data_Types::Direction_Type; --The UAV may choose a different direction for the initial timestep, depending on the circumstances.
			meet_LN : in data port Base_Types::Boolean; --True iff this UAV and its left neighbor are co-located
			meet_RN : in data port Base_Types::Boolean; --True iff this UAV and its right neighbor are co-located
			id : in data port Base_Types::Integer; --a positive integer between 1 and N
			pos : in data port DPSS_Data_Types::Position_Type;
			
			--Outputs
			direction: out data port DPSS_Data_Types::Direction_Type;
			goal : out data port DPSS_Data_Types::Position_Type;
					
		annex agree {**
			
			-----------------------------------------------------
			--STATE VARIABLES
			-----------------------------------------------------		
				
			--Shared border positions
			eq S_L : DPSS_Data_Types::Position_Type = 
				real(id-1)*DPSS_Constants.P_GLOBAL/DPSS_Constants.N_real;  
			eq S_R : DPSS_Data_Types::Position_Type = 
				real(id)*DPSS_Constants.P_GLOBAL/DPSS_Constants.N_real;	
				
			--Previous direction
			eq pre_direction : DPSS_Data_Types::Direction_Type = 
				prev(direction, suggested_initial_direction);
									
			-----------------------------------------------------
			--ASSUMPTIONS
			-----------------------------------------------------		
			
			assume "ID in range":
				id >= 1 and id <= DPSS_Constants.N_int;
						
			assume "ID is fixed":
				true -> (id = pre(id));
							
			assume "Suggested initial direction is LEFT or RIGHT":
				(suggested_initial_direction = DPSS_Constants.LEFT
					or suggested_initial_direction = DPSS_Constants.RIGHT)
				-> true;
			
			assume "ID = 1 implies meet_LN is false":
				id = 1 => not meet_LN;
				
			assume "ID = N implies meet_RN is false":
				id = DPSS_Constants.N_int => not meet_RN;
						
			-----------------------------------------------------
			--GUARANTEES
			-----------------------------------------------------		

			guarantee "Direction formula":
				direction = (
					-- Turn around at the left boundary.
					if pos <= 0.0 then
						1
					else 
						-- Turn around at the right boundary.
						if pos >= DPSS_Constants.P_GLOBAL then
							-1
						else 
							-- If meeting left neighbor, travel together toward shared border.
							if meet_LN then
								if pos <= S_L then
									1
								else --pos > S_L
									-1
							else
								-- If meeting right neighbor, travel together toward shared border. 
							  	if meet_RN then
									if pos < S_R then
										1
									else --pos >= S_R
										-1 
								-- In all other cases, proceed in the same direction.
								else 
									pre_direction
				);  

			guarantee "Goal formula":
				goal = (
						-- If co-located with left and right neighbors,...
						if meet_LN and meet_RN then
							--...and at or to the left of the shared border with the left neighbor, make goal the shared border with the right neighbor.
							if pos <= S_L then
								S_R
							--...and to the right of the shared border with the left neighbor, make goal the shared border with the left neighbor.
							else -- pos > S_L
								S_L 
						else		
							-- If co-located with left neighbor only,...
							if meet_LN then
								--...and at or to the left of the shared border with the left neighbor, make goal the right endpoint.
								if pos <= S_L then
									DPSS_Constants.P_GLOBAL
								--...and to the right of the shared border with the left neighbor, make goal the shared border with the left neighbor.
								else -- pos > S_L
									S_L
							else 
								-- If co-located with right neighbor only,...
								if meet_RN then
									--...and at or to the right of the shared border with the right neighbor, make goal the left endpoint.
									if pos >= S_R then
										0.0
									--...and to the left of the shared border with the right neighbor, make goal the shared border with the right neighbor.
									else -- pos < S_R
										S_R
								else -- If not co-located with either neighbor,...
									-- ...and heading right, set goal to the right endpoint. 
									if direction = 1 then
										DPSS_Constants.P_GLOBAL
									  -- ...and heading left, set goal to the left endpoint.
									else --direction = -1 
										0.0 
				); 
			
		**};
		
	end UAV;
end UAV_Pkg;