package AssignmentTreeBranchBoundBase_Pkg
public
    -- Include DataTypes
	with CMASI;
    with UXTASK;

    -- Includes
	with ServiceBase_Pkg;
    
    -- This is a "dummy" top-level system. We use it so that we can check 
	--  "properties" of our component contract.
	process top_level
		annex agree {**
				
			eq event_AssignmentCostMatrix_in : bool;
			assume "event_AssignmentCostMatrix_in is assumed to occur sporadically with an inter arrival time no sooner than 1600ms" :
				condition event_AssignmentCostMatrix_in occurs sporadic with IAT 1.6;
		**};
	end top_level;
	
	process implementation top_level.Impl
		subcomponents
			sub : thread AssignmentTreeBranchBoundBase; 
		annex agree {**
				assign event_AssignmentCostMatrix_in = event(sub.AssignmentCostMatrix_in);
				
			-- These lemmas could be captured in SpeAR as properties
			
			--States to check for reachability:
			    -- IDLE
			    -- WAIT 
			
			-- These lemmas could be captured in SpeAR as oberservers (without the negation)
			lemma "False indicates the INIT state is reachable" : sub.state != sub.IDLE; 
			lemma "False indicates the IDLE state is reachable" : sub.state != sub.WAIT; 

			lemma "True indicates we have enumerated all states in the reachability observers" :
				sub.state = sub.IDLE or
				sub.state = sub.WAIT; 
				
			lemma "False indicates idle_to_wait transition is executable/reachable" : 
           		 not sub.idle_to_wait;
           	
           	lemma "False indicates wait_to_idle transition is executable/reachable" : 
           		 not sub.wait_to_idle;
           		 
           	lemma "True if only stated transitions are executed (no missing transitions)." :
                sub.some_transition or sub.state = sub.previous_state;	
										
				
		**};
	end top_level.Impl;	
	
	
	thread AssignmentTreeBranchBoundBase extends ServiceBase_Pkg::ServiceBase
        features
            TaskPlanOptions_in: in event data port uxtask::TaskPlanOptions.i;
            AssignmentCostMatrix_in: in event data port uxtask::AssignmentCostMatrix.i;
            UniqueAutomationRequest_in: in event data port uxtask::UniqueAutomationRequest.i;
            ServiceStatus_out: out event data port cmasi::ServiceStatus.i;
            TaskAssignmentSummary_out: out event data port uxtask::TaskAssignmentSummary.i;
            
      	annex agree
      	{**
      		eq state : int;
       		
       		--Task States
       		const IDLE : 				int = 1;
       		const WAIT : 				int = 2;

       	-------------------------------------------------------------
		--State machine support macros
			eq previous_state: int = prev(state,IDLE);
			eq some_transition: bool = idle_to_wait
										or wait_to_idle; 
		-------------------------------------------------------------		

		--------------------------State Transition Predicates-----------------------------------
      		
      		--Upon reception of a UniqueAutomationRequest, this service enters the wait state 
      		eq idle_to_wait : bool =  false ->
      			previous_state = IDLE and 
      			pre(event(UniqueAutomationRequest_in));
      		--The results of the optimization are packaged into the TaskAssignmentSummary and published, 
      		--at which point this service returns to the idle state.
      		eq wait_to_idle : bool = false ->
      			previous_state = WAIT and
      			pre(event(TaskAssignmentSummary_out));
      			
      		-- Other internal transitions --
      		
      		eq send_task_assignment_summary : bool = false ->
      			state = WAIT and 
      			event(AssignmentCostMatrix_in) and 
      			AssignmentCostMatrix_in.CorrespondingAutomationRequestID = curUniqueAutomationRequestID and
      			allExpectedTaskOptionsReceived;
      			
      		
      		--NOTE: CANNOT FORMALIZE WITHOUT ARRAY SUPPORT (NO WAY TO TIE VARIABLE TO INPUT PORTS)	
      		--True if while in the wait state, all taskoptions are received for all tasks in the request
      		--TaskOptions must match the UniqueAutomationRequest ID to be valid. 
      		--According to Derek, option tasks may come in that overwrite existing tasks. This may
      		--in the future be considered an error, but currently if it where to happen they are allowing the overwrite. 
      		eq allExpectedTaskOptionsReceived : bool ;
      		
      		eq curUniqueAutomationRequestID : int;
      		
      		guarantee "Self loops": not some_transition => (state = previous_state);
      	
      		--NOTE: the transition occurs on the time step after receiving the UniqueAutomationRequest
      		guarantee "[In the idle state] Upon [changed to 'after'] reception of a UniqueAutomationRequest, this service enters the wait state ": 
      			idle_to_wait =>
      				state = WAIT;
      		
--      			if idle_to_wait then
--      				state = WAIT and
--      				curUniqueAutomationRequestID = UniqueAutomationRequest_in.RequestID
--      			else
--      				curUniqueAutomationRequestID = pre(curUniqueAutomationRequestID);
      			
      		guarantee "[Upon receiving a UniqueAutomationRequest_in in the IDLE state, the ID is cached]":
      			if state = IDLE and event(UniqueAutomationRequest_in) then
      				curUniqueAutomationRequestID = UniqueAutomationRequest_in.RequestID
      			else
      				curUniqueAutomationRequestID = pre(curUniqueAutomationRequestID);

      		
      		guarantee "[ADDED GURANTEE]: In IDLE, there are no expected task options (clear the flag, i.e., set to false) ":
      		 	state = IDLE  =>
      				allExpectedTaskOptionsReceived = false;
      		
      		--NOTE: although there is an expectation about the ordering in which the RouteAggregatorService sends out
      		--the AssignmentCostMatrix relative to receiving Taskoptions, there is no intrinsic need to assume this ordering here (verified with Derek).
      		--We instead allow the TaskOptions and Matrix to come in in any order. Upon receiving the requisite task and matrix the summary is sent out. 
      		guarantee "Upon receiving the AssignmentCostMatrix (which should be received strictly after the TaskPlanOptions
      			due to the behavior of the RouteAggregatorService), this service conducts the branch-and-bound search to determine 
      			the proper ordering and assignment of Tasks to vehicles. The results of the optimization are packaged into the TaskAssignmentSummary":
      			if send_task_assignment_summary then
      				event(TaskAssignmentSummary_out)
      			else
      				not event(TaskAssignmentSummary_out);
      				
      		guarantee "The results of the optimization are packaged into the TaskAssignmentSummary and published, 
      			at which point this service returns to the idle state.":
      			wait_to_idle =>
      				state = IDLE and
      				allExpectedTaskOptionsReceived = false; --redundant, but explicit
      				
      				
      		--Timing properties
      		
--      		"Response" to UniqueAutomationRequest_in
--      		idle -> wait, store request ID for identification of corresponding TaskPlanOptions and AssignmentCostMatrix.
      		
      		eq event_UniqueAutomationRequest_in : bool = event(UniqueAutomationRequest_in);
      		eq event_uar_in_idle_state : bool = event_UniqueAutomationRequest_in and state = IDLE;
      		guarantee "The service transitions to WAIT within 0ms of receiving UniqueAutomationRequest_in from the IDLE state":
      			whenever event_uar_in_idle_state occurs idle_to_wait occurs during [0.0,0.0000001];
      			
      		eq uar_id_cached : bool = curUniqueAutomationRequestID = UniqueAutomationRequest_in.RequestID;
      		guarantee "The service caches the ID of a received UniqueAutomationRequest_in within 0ms in the IDLE state":
      			whenever event_uar_in_idle_state occurs uar_id_cached occurs during [0.0,0.0000001];
      		
--      		"Response" to AssignmentCostMatrix_in
--      		Using the cost of each task option (from the stored TaskPlanOptions messages) 
--      		and the cost for each vehicle to reach each option (from AssignmentCostMatrix), 
--      		perform an optimization attempting to find the minimal cost mission that adheres to the 
--      		Process Algebra contraints. Upon completion, emit TaskAssignmentSummary and wait -> idle.

			eq event_TaskAssignmentSummary_out : bool = event(TaskAssignmentSummary_out);
			eq event_AssignmentCostMatrix_in : bool = event(AssignmentCostMatrix_in);
			eq event_acm_in_wait_state : bool = event_AssignmentCostMatrix_in and state = WAIT;
			
			--NOTE: needed to address bound conccern. 
			assume "event_AssignmentCostMatrix_in is assumed to occur sporadically with an inter arrival time no sooner than 1600ms" :
				condition event_AssignmentCostMatrix_in occurs sporadic with IAT 1.6;
			
			guarantee "TaskAssignmentSummary_out is emitted within 1500ms after receiving AssignmentCostMatrix_in in the WAIT state":
				whenever event_acm_in_wait_state occurs event_TaskAssignmentSummary_out occurs during [0.0,1.5];
				
			guarantee "The service transitions to IDLE within 1500ms after receiving AssignmentCostMatrix_in in the WAIT state ":
				whenever event_acm_in_wait_state occurs wait_to_idle occurs during [0.0,1.5];
      	**};
    end AssignmentTreeBranchBoundBase;

    
end AssignmentTreeBranchBoundBase_Pkg;