package RouteAggregatorService_AggregatorRole_Pkg
public
	with CMASI;
    with IMPACT;
    with ROUTE;
    with UxAS_Node_Lib;

	-- This is a "dummy" top-level system. We use it so that we can check 
	--  "properties" of our component contract.
	process top_level
		annex agree {**
			guarantee "Placeholder guarantee to force AGREE to run" : true;
		**};
	end top_level;
	
	process implementation top_level.Impl
		subcomponents
			sub : thread RouteAggregatorService_AggregatorRole; 
		annex agree {**
			------------------------------------------------------
			-- These lemmas could be captured in SpeAR as properties
			lemma "num_route_requests_being_serviced >= 0" : sub.num_route_requests_being_serviced >= 0;
			
			--State machine lemmas
			lemma "The value of the state variable corresponds to a 'real' state." :
				(sub.state = sub.IDLE) 
				or (sub.state = sub.PENDING);
			lemma "Only stated transitions are allowed." :
				sub.some_transition or (sub.state = sub.previous_state);
			------------------------------------------------------
			-- These lemmas could be captured in SpeAR as observers (without the negation)
			
			--Check that all states are reachable
			lemma "False indicates the IDLE state is reachable" : not (sub.state = sub.IDLE); 
			lemma "False indicates the PENDING state is reachable" : not (sub.state = sub.PENDING);
			
			--Check that all state transitions are reachable
			lemma "False indicates that T_IDLE_TO_PENDING is reachable" : not sub.T_IDLE_TO_PENDING;
			lemma "False indicates that T_PENDING_TO_IDLE is reachable": not sub.T_PENDING_TO_IDLE;
			
			--Check that events are possible
			lemma "False indicates the system is able to produce a route response" : not event(sub.RouteResponse_out);
			lemma "False indicates the system is able to produce a route plan request" : not event(sub.RoutePlanRequest_out);
			lemma "False indicates the system is able to receive a route plan response": not event(sub.RouteRequest_in);
			lemma "False indicates the system is able to receive a route request": not event(sub.RoutePlanResponse_in);
		**};
		 
	end top_level.Impl;	
	
thread RouteAggregatorService_AggregatorRole
	features
		-- These features are specific versions of the base entity type, replace with the base type
--        GroundVehicleConfiguration_in: in event data port impact::GroundVehicleConfiguration.i; 
--        SurfaceVehicleConfiguration_in: in event data port impact::SurfaceVehicleConfiguration.i; 
--        AirVehicleConfiguration_in: in event data port cmasi::AirVehicleConfiguration.i;
        EntityConfiguration_in: in event data port CMASI::EntityConfiguration.i; 
        
        RouteRequest_in: in event data port route::RouteRequest.i; 
        RoutePlanResponse_in: in event data port route::RoutePlanResponse.i;
        ServiceStatus_out: out event data port cmasi::ServiceStatus.i; --This port is not mentioned in the Wiki. Per Derek, it is used for error reporting (or at least can be used for that.)
        RoutePlanRequest_out: out event data port route::RoutePlanRequest.i;
        RouteResponse_out: out event data port route::RouteResponse.i;
   	annex agree{**
  		-------------------------------------------------------------
  		-- BEGIN STATE MACHINE LOGIC
		-------------------------------------------------------------
		--State constants
 		const IDLE : int = 0;
        const PENDING : int = 1;

		-------------------------------------------------------------
		--State variable
		eq state: int;

		-------------------------------------------------------------
		--State machine support macros		

		eq previous_state: int = prev(state, IDLE);

		eq some_transition: bool = T_IDLE_TO_PENDING
									or T_PENDING_TO_IDLE;

		-------------------------------------------------------------
		--Helper macro for this particular state machine
		eq num_route_requests_being_serviced : int = 
			0 -> 
				(pre(num_route_requests_being_serviced) 
					+ UxAS_Node_Lib.bool_to_int(event(RouteRequest_in)) 
					- UxAS_Node_Lib.bool_to_int(event(RouteResponse_out))
				);
				
		-------------------------------------------------------------	
		--State transition macros
		
		--This is initially false to prevent transition to PENDING on the initial timestep
		--Note: The documentation seems to say we also need to create a table and send the RoutePlanRequest messages
		--  before moving to IDLE. We could possibly introduce another state between IDLE and PENDING for "setup"; 
		--  but since I'm not modeling those details currently, I think it's okay to move to PENDING as soon as we receive
		--  RouteRequest_in.
		eq T_IDLE_TO_PENDING : bool = 
			false -> ((previous_state = IDLE) and event(RouteRequest_in));
		
		--Since we may be servicing multiple requests at a time, we stay in pending until all requests have been 
		-- serviced, in which case we return to IDLE
		eq T_PENDING_TO_IDLE : bool = 
			(previous_state = PENDING) and (num_route_requests_being_serviced = 0);
			
		-------------------------------------------------------------	
		--State machine guarantees
				
		--This guarantee specifies the initial state.
        guarantee "Initial_State": (state = IDLE) -> true;
        
        --This guarantee captures all the "self loops" in shorthand form. 
        -- It is important to state what happens when no transition condition is satisfied.
        -- Otherwise the model checker will allow "spontaneous" transitions.
        guarantee "Self loops": not some_transition => (state = previous_state);
        
        -- Now we write one guarantee for each transition.
        
        --If we had other actions to take on this transition, we would include those in the consequent as well. 
        guarantee "T_IDLE_TO_PENDING_effect" : T_IDLE_TO_PENDING => (state = PENDING);
        
        guarantee "T_PENDING_TO_IDLE_effect" : T_PENDING_TO_IDLE => (state = IDLE);

		-------------------------------------------------------------
		-- END STATE MACHINE LOGIC
		-------------------------------------------------------------
		
		-------------------------------------------------------------
		-------------------------------------------------------------
		-- The guarantees in this section capture correct component behavior.
		-- The set is not necessarily complete.
		
		guarantee "Only produce a route response when previous state was PENDING": 
			event(RouteResponse_out) => (previous_state = PENDING);
	
		guarantee "Only produce a route plan request when the previous state was PENDING": 
			event(RoutePlanRequest_out) => (previous_state = PENDING);	

		-- Should we pick a time window so that we can state the following property? 
		--   RouteRequest_in => within X we get a RouteResponse_out with a matching ID
		--   We would need to assume that the route planners respond in a timely manner
		--   in order to guarantee that.
		-- Per Dereck, the route plan requests go out very quickly (could model as consecutive timesteps). Would take maybe 10 ms for the route planners to respond to each.

		-------------------------------------------------------------
		-- Guarantees that need arrays, or records mimicking arrays, to formally express.
		
		-- The locations and destinations (first and last waypoints) of the route plans in the responses should match the requests, or an error should be produced.
		-- This is something the route planners should guarantee, and we could check that the originator of the RouteRequst receives 
		-- routes that satisfy this if we could guarantee that this RouteAggregator Service passed on the routes from the planners without
		-- modifying them, but we can't do that without building the array of responses or changing the data structure (interface)
		-- somehow.	
		
		--Think of these Boolean variables as a predicates
		--Q from Derek: Can we implement the behavior in the AADL implementation?
		--Aaron thinks yes.
		
		eq route_response_consists_of_route_plan_responses_received : bool;
		guarantee "The routes in RouteResponse_out are the route plan responses received." :
			route_response_consists_of_route_plan_responses_received; --guarantee that this predicate is true
		
		eq route_plan_request_sent_for_each_vehicleID : bool;	
		guarantee "For each vehicle ID in the VehicleID array of the route request, a route plan request message is sent
		    with a matchine Vehicle ID (and the rest of the contents the same)":
		    route_plan_request_sent_for_each_vehicleID; --guarantee that this predicate is true
		
		-------------------------------------------------------------
		-- The guarantees below this line depend on some internal state. That is difficult to
		--  express for a RouteAggregatorService that can service an arbitrary number of 
		--  requests at a time. We would be forced to fix the number it can serve to some max
		--  for modeling purposes. Not sure we want to do that.
		--  Q for Sean/Derek: Does it really serve an arbitrary number or is there a max?
		--	A from Sean: It's variable, depending on number of requests you make.
		
		-- Note: I do have a formal version of these guarantee in RouteAggregatorService_OneRequestAtATime
		--
		-- Tony: Maybe this can be done with variables for current request and associated route plan request.
		-- Jen: The new version below does just that. (Thanks, Tony!)
		
		--old version
		-- eq contents_of_route_plan_requests_match_contents_of_associated_route_request : bool;
		-- guarantee "contents_of_route_plan_requests_match_contents_of_associated_route_request" :true;
		
		--The route request for which we are making new route plan requests
		eq RouteRequest_being_serviced : route::RouteRequest.i; 
		
		guarantee "Contents of route plan requests match contents of the associated route request (except VehicleID and RequestID)":
				event(RoutePlanRequest_out) =>
				((RoutePlanRequest_out.AssociatedTaskID = RouteRequest_being_serviced.AssociatedTaskID)
					and (RoutePlanRequest_out.OperatingRegion = RouteRequest_being_serviced.OperatingRegion)
					and (RoutePlanRequest_out.RouteConstraints = RouteRequest_being_serviced.RouteConstraints)
					and (RoutePlanRequest_out.IsCostOnlyRequest = RouteRequest_being_serviced.IsCostOnlyRequest)
				);
		

		-- We may want to add a guarantee about sending the route plan requests within some
		--  timeframe. For now, as modeled, this service could sit on them forever. 
		
		eq produce_route_response_once_all_route_plan_responses_have_been_received : bool;
		guarantee "Produce route response output once all route plan responses have been received" : 
			produce_route_response_once_all_route_plan_responses_have_been_received;
		
		eq RouteRequest_being_responded_to : route::RouteRequest.i; 
		
		guarantee "Response ID in the route response should match the ID in the associated route request." :
			event(RouteResponse_out) => (RouteResponse_out.ResponseID = RouteRequest_being_responded_to.RequestID);
			
		-- Adding a cache capability to ensure that each RoutePlanRequest_out is based off of a unique vehicleID
		-- Get the number of vehicles from the route request
		eq numVehicleIDs : int;
		guarantee "For each vehicle in the RouteRequest, the number of vehicles will govern the number of route plan requests" :
            event_RouteRequest_Recvd => (numVehicleIDs = RouteRequest_in.NumVehicleIDs) and (state = PENDING);
        
        -- Cache the RequestIDs of the RoutePlanRequests dependent 
        guarantee "":
            

        
		 
			
		
		-- Q: Is the ResponseID in the route plan responses enough to ensure the message is the response we're expecting? 
		-- Do we have any system-level guarantees about uniqueness of these IDs? 
		-- A from Derek: No.
		-- All agreed it may be an issue that two tasks could make a request with the same ID. 
		--  They would both think the response is for them. And this service could be confused too.
			
		------------------------------------------------------------
		-- Below is some Q&A. Discussion held 6/13/17 with Jen, Aaron, Sean, Ben R., and John B. 
		
		-- Q: What will the top-level UxAS use from this? It doesn't have visibility into the internal state... 
		-- John: Modeling the state makes sense if we have a system-level guarantee that references it.
		-- Ben: Higher level req may be if all responses are received, response is sent out.
		-- John: We could try to figure out our system-level reqts first and model the Wiki more coarsely.
		
		-- Q (Philosophical): Should component contracts include only what we need for architectural level reasoning,
		--  or should the contracts be sufficiently detailed so that any component satisfying the contract will
		--  result in a correctly functioning system? Or would one argue that these are in fact the same?
		-- John: In general, a component contract should have at least enough info to prove system-level reqts.
		-- 	Component reqts need to trace to some system reqt.
		-- Ben: But sometimes we build components out of context. Maybe some are identified for "plug-and-play." Those may
		--  be over-designed.
		-- Aaron: Contracts should ensure that a replacement component gives us the same functionality that we had 
		--  previously. 
		 
		--  Currently, my contracts on this component are not nearly sufficient to ensure correctness. The output
		--  messages could be jibberish. Even if I require the response ID to match the request ID, the
		--  rest of the information could be garbage.
		
		--------------------
		-- Timing Properties
		--------------------
		
        -- TODO: ASK DEREK: Arbitary number chosen for max number of RoutePlanRequests
        const MAX_VEH_IDS : int = 2000;
        
        -- The system should return a RoutePlanResponse for every sent RoutePlanRequest
        eq totalRoutePlanRequests: int;
        eq numRoutePlanResponses_Recvd : int;

        assume "The maximum number of RoutePlanRequests is dependant on the number of VehicleIDSs which must be greater than 0 and less than or equal to MAX_VEH_IDS" :
            event(RouteRequest_in) => 
                RouteRequest_in.NumVehicleIDs > 0 and RouteRequest_in.NumVehicleIDs <= MAX_VEH_IDS;

        -- Timing on a received occurance of a route request
        -- Notes:
        --  idle -> pending, indexed by RouteRequest request ID, create a checklist of expected responses. 
        --  Emit a number of RoutePlanRequest messages equal to the number of vehicles in the VehicleID field of the original RouteRequest
        -- AWF (20170808)
        --  We can state that at the time a RouteRequest comes in the system will transition and produce RoutePlanRequests.
        --  I am not sure how we can say anything about how many RoutePlanRequests are generated
        eq event_RouteRequest_Recvd : bool = (event(RouteRequest_in) and (state = IDLE));
        eq event_RoutePlanRequest_Sent : bool = (event(RoutePlanRequest_out) and (state = PENDING) and );
                
        guarantee "[STUB] (Idle -> Pending) Received a Route Request" :
            whenever event_RouteRequest_Recvd occurs event_RoutePlanRequest_Sent occurs during [0.0,0.001];

        -- Timing on when an EntityConfiguration is received
        -- Notes:
        --  Vehicle capabilities (e.g. allowable speeds) are described by entity configuration messages. 
        --  This service uses the EntityConfiguration to determine which type of vehicle corresponds to a specific ID 
        --  so that ground planners are used for ground vehicles and air planners are used for aircraft.
        --  No state change. Store to identify appropriate route planner by vehicle ID.         
        eq event_EntityConfig_Recved : bool = (event(EntityConfiguration_in) and (state = PENDING));
        eq storeData : bool; -- When true the appropriate data has been stored
        eq dataStore_VehCapabilities : bool = (storeData and (state = PENDING));
        
        guarantee "[STUB] (Pending) Received a Entity Configuration":
            whenever event_EntityConfig_Recved occurs dataStore_VehCapabilities occurs during [0.0,0.000];
            
        -- Timing on a reception of a RoutePlanResponse
        -- Notes:
        --  This message is the fulfillment of a single vehicle route plan request which the Aggregator 
        --  catalogues until the complete set of expected responses is received.
        --  Store response and check to see if this message completes any checklist. 
        --  If a checklist is complete, use the corresponding request ID to create a complete RouteResponse message. 
        --  Emit RouteResponse and pending -> idle.
        eq numPendingPlanResponses : int = MAX_VEH_IDS;
        eq event_RPR_Recvd : bool = event(RoutePlanResponse_in) and (state = PENDING)
        
--        eq event_expected_UniqueAutomationRequest_in: bool =
--                (event(UniqueAutomationRequest_in)  and unique_automation_request_task_id_present);
--        eq event_uar_request_in_idle_state : bool = state = IDLE and event_expected_UniqueAutomationRequest_in;
--        eq event_SensorFootprintRequests_out: bool = event(SensorFootprintRequests_out);
--        guarantee "SensorFootprintRequests_out is emitted within 2ms of receiving UniqueAutomationRequest_in in the IDLE state":
--            whenever event_uar_request_in_idle_state occurs event_SensorFootprintRequests_out occurs during [0.0,0.002];
--                    
--        guarantee "The task transitions to SENSOR_REQUEST within 2ms of UniqueAutomationRequest_in in the IDLE state":
--            whenever event_uar_request_in_idle_state occurs idle_to_sensor_request occurs during [0.0,0.002];
--                
--        eq event_uar_request_in_option_selected_state : bool = state = OPTION_SELECTED and event_expected_UniqueAutomationRequest_in;
--        guarantee "SensorFootprintRequests_out is emitted within 2ms of receiving UniqueAutomationRequest_in in the OPTION_SPELETECTED state" :
--            whenever event_uar_request_in_option_selected_state occurs event_SensorFootprintRequests_out occurs during [0.0,0.002];
--                    
--        guarantee "The task transitions to SENSOR_REQUEST within 2ms of UniqueAutomationRequest_in in the OPTION_SELECTED state":
--            whenever event_uar_request_in_option_selected_state occurs option_selected_to_sensor_request occurs during [0.0,0.002];
--                    
----        "Response" to TaskImplementationRequest_in
----        OptionsPublished -> FinalRoutes, emit RouteRequest to determine final waypoint routes needed for implementation
--
--        eq event_TaskImplementationRequest : bool = event(TaskImplementationRequest_in);
--        eq event_tir_in_options_published_state : bool = state = OPTIONS_PUBLISHED and event_TaskImplementationRequest;
--        eq event_RouteRequest_out : bool = event(RouteRequest_out);

	**};
end RouteAggregatorService_AggregatorRole;

-- Thought from Derek: It would be valuable to do some (simple) functions in AADL implementations. But 
--   keep things like route planning to code rather than implementing here.
--   Think about what could be moved here for message processing, state machines, etc.


end RouteAggregatorService_AggregatorRole_Pkg;