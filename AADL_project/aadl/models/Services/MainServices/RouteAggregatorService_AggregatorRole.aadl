package RouteAggregatorService_AggregatorRole_Pkg
public
	with CMASI;
    with IMPACT;
    with ROUTE;
    with UxAS_Node_Lib;
    with Base_Types;
    
    
    data Int_to_Bool_3_by_3_Table_Type
	end Int_to_Bool_3_by_3_Table_Type;
	
	data implementation Int_to_Bool_3_by_3_Table_Type.Impl
		subcomponents
			--BDR: Syntax issues with setting up a const default/init table
			--having to instead store OriginalRouteRequests in separate variables
			--OriginalRouteRequest : data route::RouteRequest.i;
			number_of_requests : data Base_Types::Integer;
			ID1: data Base_Types::Integer;
			ID2: data Base_Types::Integer;
			ID3: data Base_Types::Integer;
			sent_ID1: data Base_Types::Boolean;
			sent_ID2: data Base_Types::Boolean;
			sent_ID3: data Base_Types::Boolean;
			recd_ID1: data Base_Types::Boolean;
			recd_ID2: data Base_Types::Boolean;
			recd_ID3: data Base_Types::Boolean;
	end Int_to_Bool_3_by_3_Table_Type.Impl;
	

	-- This is a "dummy" top-level system. We use it so that we can check 
	--  "properties" of our component contract.
	process top_level
		features
			RouteRequest_in: in event data port route::RouteRequest.i; 
        	RoutePlanResponse_in: in event data port route::RoutePlanResponse.i;
        
        	RoutePlanRequest_out: out event data port route::RoutePlanRequest.i;
        	RouteResponse_out: out event data port route::RouteResponse.i;
		annex agree {**
			guarantee "Placeholder guarantee to force AGREE to run" : true;
			
		eq route_requests_received_counter : int;
		assume "No more than three RouteRequest_in total can ever be received by this service":
			route_requests_received_counter <=3;
			
		assume "No more than 3 vehicles are specified within a RouteRequest_in and 
			at least one vehicle is specified." :
			event(RouteRequest_in) => 
				(RouteRequest_in.NumVehicleIDs >0 and 
					RouteRequest_in.NumVehicleIDs <= 3);
					
		eq event_RoutePlanResponse_in : bool = event(RoutePlanResponse_in);
		assume "Both timing properties and other misc. logic of this spec assumes that 
			all RoutePlanResponse_in for a given RouteRequest_in is received no sooner than 2ms
			 (a RouteResponse_out must be sent out before the next RoutePlanResponse_in can be received)" :
			condition event_RoutePlanResponse_in occurs sporadic with IAT 0.002;
			
		eq event_RouteRequest_in : bool = event(RouteRequest_in);
		assume "Both timing properties and other misc. logic of this spec assumes that 
			RouteRequest_in is received no sooner than 3ms (a RouteRequest_in must complete
			sending all of its corresponding RoutePlanRequest_out before the next RouteRequest_in can be received)" :
			condition event_RouteRequest_in occurs sporadic with IAT 0.003;
		**};
	end top_level;
	
	process implementation top_level.Impl
		subcomponents
			sub : thread RouteAggregatorService_AggregatorRole; 
		connections
			conn0: port RouteRequest_in -> sub.RouteRequest_in;
			conn1: port RoutePlanResponse_in -> sub.RoutePlanResponse_in;
			conn2: port sub.RoutePlanRequest_out -> RoutePlanRequest_out;
			conn3: port sub.RouteResponse_out -> RouteResponse_out;
		annex agree {**
				assign route_requests_received_counter = (0 ->
					(if event(RouteRequest_in) then
						pre(route_requests_received_counter)+1
					else
						pre(route_requests_received_counter)
					));
			
			------------------------------------------------------
			-- These lemmas could be captured in SpeAR as properties
--			lemma "num_route_requests_being_serviced >= 0" : sub.num_route_requests_being_serviced >= 0;
			
			--Check that events are possible
			lemma "False indicates the system is able to produce a route response" : not event(sub.RouteResponse_out);
			lemma "False indicates the system is able to produce a route plan request" : not event(sub.RoutePlanRequest_out);
			lemma "False indicates the system is able to receive a route plan response": not event(sub.RouteRequest_in);
			lemma "False indicates the system is able to receive a route request": not event(sub.RoutePlanResponse_in);
		**};
		 
	end top_level.Impl;	
	
thread RouteAggregatorService_AggregatorRole
    features
        --TODO: Where are these coming from? 
        --TODO: Comment out and insert an EntityConfiguration type
        GroundVehicleConfiguration_in: in event data port impact::GroundVehicleConfiguration.i; 
        SurfaceVehicleConfiguration_in: in event data port impact::SurfaceVehicleConfiguration.i; 
        AirVehicleConfiguration_in: in event data port cmasi::AirVehicleConfiguration.i; 
        
        RouteRequest_in: in event data port route::RouteRequest.i; 
        RoutePlanResponse_in: in event data port route::RoutePlanResponse.i;
        
        ServiceStatus_out: out event data port cmasi::ServiceStatus.i; --This port is not mentioned in the Wiki. Per Derek, it is used for error reporting (or at least can be used for that.)
        RoutePlanRequest_out: out event data port route::RoutePlanRequest.i;
        RouteResponse_out: out event data port route::RouteResponse.i;
   	annex agree{**
				
		eq route_requests_received_counter : int  = 
			0 -> (pre(route_requests_received_counter) 
					+ UxAS_Node_Lib.bool_to_int(event(RouteRequest_in)));
					
		const MAX_ROUTE_REQUESTS_SERVICABLE : int = 3;
		
		--Note: this assumption is vital to the correct use of this component, so I am leaving
		--the assumption within the component (not assuming solely at a higher level)
		assume "No more than three RouteRequest_in total can ever be received by this service":
			route_requests_received_counter <=3;
		
		--Note: to address the capability of the aggregator to service multiple requests at once
		--the states as specified in the wiki are not encoded here. There is one state in which
		--requests are received and serviced. 
		
	------------------------------------------------------------
		-- The guarantees below this line depend on some internal state. That is difficult to
		--  express for a RouteAggregatorService that can service an arbitrary number of 
		--  requests at a time. We would be forced to fix the number it can serve to some max
		--  for modeling purposes. Not sure we want to do that.
		--  Q for Sean/Derek: Does it really serve an arbitrary number or is there a max?
		--	A from Sean: It's variable, depending on number of requests you make.
		
		-- Note: We do have a formal version of these guarantee in RouteAggregatorService_OneRequestAtATime
		--
		-- Tony: Maybe this can be done with variables for current request and associated route plan request.
		-- Jen: The new version below does just that. (Thanks, Tony!)
		--
		-- Follow up: (Ben R.) The version below combines concepts from the one at a time aggegator and what was 
		-- previous developed. This represents a hybrid approach with sufficient detail to allow for a meaningful 
		-- notion of timing while also allowing the service to maintain IDs which will be necessary for other services
		-- to satisfy their guarantees. 
		
		--old version
		-- eq contents_of_route_plan_requests_match_contents_of_associated_route_request : bool;
		-- guarantee "contents_of_route_plan_requests_match_contents_of_associated_route_request" :true;
		
		
		-- eq produce_route_response_once_all_route_plan_responses_have_been_received : bool;
		-- guarantee "Produce route response output once all route plan responses have been received" : 
			-- produce_route_response_once_all_route_plan_responses_have_been_received;
			
		--Think of these Boolean variables as a predicates
		--Q from Derek: Can we implement the behavior in the AADL implementation?
		--Aaron thinks yes.
		
		eq route_response_consists_of_route_plan_responses_received : bool;
		guarantee "The routes in RouteResponse_out are the route plan responses received." :
			route_response_consists_of_route_plan_responses_received; --guarantee that this predicate is true
		
		eq route_plan_request_sent_for_each_vehicleID : bool;	
		guarantee "For each vehicle ID in the VehicleID array of the route request, a route plan request message is sent
		    with a matchine Vehicle ID (and the rest of the contents the same)":
		    route_plan_request_sent_for_each_vehicleID; --guarantee that this predicate is true
		    
		    
		--The route request for which we are making new route plan requests
		-- Note: due to other assumptions of this model, the current request being serviced will not change
		-- between when the route request is received and the route plan requests are sent (due to timing bounds assumptions)
		eq RouteRequest_being_serviced : route::RouteRequest.i; 
		
		guarantee "Contents of route plan requests match contents of the associated route request (except VehicleID and RequestID)":
				event(RoutePlanRequest_out) =>
				((RoutePlanRequest_out.AssociatedTaskID = RouteRequest_being_serviced.AssociatedTaskID)
					and (RoutePlanRequest_out.OperatingRegion = RouteRequest_being_serviced.OperatingRegion)
					and (RoutePlanRequest_out.RouteConstraints = RouteRequest_being_serviced.RouteConstraints)
					and (RoutePlanRequest_out.IsCostOnlyRequest = RouteRequest_being_serviced.IsCostOnlyRequest)
				);

		-------------------------------------------------------------
		-- Guarantees that need arrays, or records mimicking arrays, to formally express.
		--  The guarantees below this line depend on some internal state. Do we want to keep them? They seem important for 
		--   correctness, but also force us to pick a fixed size for the VehicleID array, etc.
		
		

		-- NOTE: The locations and destinations (first and last waypoints) of the route plans in the responses should match the requests, or an error should be produced.
		-- This is something the route planners should guarantee, and we could check that the originator of the RouteRequst receives 
		-- routes that satisfy this if we could guarantee that this RouteAggregator Service passed on the routes from the planners without
		-- modifying them, but we can't do that without building the array of responses or changing the data structure (interface)
		-- somehow.	We are using an internal table structure instead of an array to address this issue. 
		
		--  Note: I want to model the notion of storing route plan responses and, after receiving them all,
		--  sending the route response. To do that I need some internal state. I'm using a table, which is also
		--  mentioned in the Wiki for this service.  
		--  Due to the limitations of the modeling environment, I need to pick a fixed size for that table.
		--  The size of the table corresponse to the number of VehicleIDs in RouteRequest_in, which I don't
		--  know given our current data types. (It's a flexible size.)
		-- So, for now, let's assume each incoming RouteRequest has 3 vehicle IDs (so we produce 3 RoutePlanRequests).
		-- I'm also hard-coding the RequestIDs for this version to be 1, 2, and 3. This is easier to model for the time being.
		-- We can make it more flexible later if we decide to keep this table approach to modeling.

		const MAX_SIZE_OF_VehicleID_ARRAY : int = 3; --hard-coded to three for this version
		
		--Note: this assumption is vital to the correct use of this component, so I am leaving
		--the assumption within the component (not assuming solely at a higher level)
		--Note: This assumption allows for 0 RouteRequest_in messages for maximum flexibility
		--I will let parent systems force at least one Request. 
		assume "No more than 3 vehicles are specified within a RouteRequest_in and 
			at least one vehicle is specified." :
			event(RouteRequest_in) => 
				(RouteRequest_in.NumVehicleIDs >=0 and 
					RouteRequest_in.NumVehicleIDs <= MAX_SIZE_OF_VehicleID_ARRAY);
		
		eq RouteRequest1Table : RouteAggregatorService_AggregatorRole_Pkg::Int_to_Bool_3_by_3_Table_Type.Impl;
		eq RouteRequest2Table : RouteAggregatorService_AggregatorRole_Pkg::Int_to_Bool_3_by_3_Table_Type.Impl;
		eq RouteRequest3Table : RouteAggregatorService_AggregatorRole_Pkg::Int_to_Bool_3_by_3_Table_Type.Impl;
		--and so on
		
		eq RouteRequest1 : route::RouteRequest.i; 
		eq RouteRequest2 : route::RouteRequest.i;
		eq RouteRequest3 : route::RouteRequest.i;
		--and so on
		
		--Used as a general quick reference macro for the last table to be generated (i.e., the 
		--the table for the last RouteRequest)
		eq last_route_request_table :  RouteAggregatorService_AggregatorRole_Pkg::Int_to_Bool_3_by_3_Table_Type.Impl =
			if(totalRouteRequestsReceivedCounter=1) then
				RouteRequest1Table
			else if (totalRouteRequestsReceivedCounter=2) then
				RouteRequest2Table
			else --and so on
				RouteRequest3Table;
				
		eq totalRouteRequestsReceivedCounter : int = 
			0 -> (pre(totalRouteRequestsReceivedCounter) + 
					UxAS_Node_Lib.bool_to_int(event(RouteRequest_in)));

		--Note: the totalRouteRequestsReceivedCounter is incremented on the same time step
		--as a RouteRequest_in. Hence, these checks below must consider that the counter
		--is incremented within the same step when these guarantees apply.
		
		--Note: I'm not sure that I can use a const table as was originally suggested as
		--I need to in the same time step assign the const table to a varaible and change
		--the default values. That intuitively seems like a conflict. Instead, I will
		--manually set the values for each new table (probably could create a node in the future)
		
		--NOTE: the timing properties necessitate an assumption that requests 
		--cannot be received simultaneously. They are received in some sense one at a time
		--but only within the window of timing constraints. It is therefore "ok" to
		--base a guarantee on the current total requests received since later timing properties
		--correlate RouteRequest_in to RoutePlanRequest_out. A bounding assumping will
		--be specified stipulating the RouteRequest_in does not occur again before sending a
		--RoutePlanRequest_out. 
		guarantee "Intial table for the first received route request" :
			(event(RouteRequest_in) and totalRouteRequestsReceivedCounter=1) =>  
				 (RouteRequest1Table.number_of_requests = RouteRequest_in.NumVehicleIDs
				 and RouteRequest1Table.ID1 = (1 -> pre(RouteRequest1Table.ID1))
				 and RouteRequest1Table.ID2 = (2 -> pre(RouteRequest1Table.ID2))
				 and RouteRequest1Table.ID3 = (3 -> pre(RouteRequest1Table.ID3))
				 and RouteRequest1Table.sent_ID1 = (false -> (pre(RouteRequest1Table.sent_ID1) 
				 						or (event(RoutePlanRequest_out) 
				 								and RoutePlanRequest_out.RequestID = RouteRequest1Table.ID1)))
				 and RouteRequest1Table.sent_ID2 = (false -> (pre(RouteRequest1Table.sent_ID2) 
				 						or (event(RoutePlanRequest_out) 
				 								and RoutePlanRequest_out.RequestID = RouteRequest1Table.ID2)))
				 and RouteRequest1Table.sent_ID3 = (false -> (pre(RouteRequest1Table.sent_ID3) 
				 						or (event(RoutePlanRequest_out) 
				 								and RoutePlanRequest_out.RequestID = RouteRequest1Table.ID3)))
				 and RouteRequest1Table.recd_ID1 = (false -> (pre(RouteRequest1Table.recd_ID1)
				 						or (event(RoutePlanResponse_in) 
				 								and RoutePlanResponse_in.ResponseID = RouteRequest1Table.ID1)))
				 and RouteRequest1Table.recd_ID2 = (false -> (pre(RouteRequest1Table.recd_ID2)
				 						or (event(RoutePlanResponse_in) 
				 								and RoutePlanResponse_in.ResponseID = RouteRequest1Table.ID2)))
				 and RouteRequest1Table.recd_ID3 = (false -> (pre(RouteRequest1Table.recd_ID3)
				 						or (event(RoutePlanResponse_in) 
				 								and RoutePlanResponse_in.ResponseID = RouteRequest1Table.ID3)))
				 and RouteRequest1 = RouteRequest_in);
				 	
				 
		guarantee "Intial table for the second received route request" :
			(event(RouteRequest_in) and totalRouteRequestsReceivedCounter=2) =>  
				  (RouteRequest2Table.number_of_requests = RouteRequest_in.NumVehicleIDs
				 and RouteRequest2Table.ID1 = (4 -> pre(RouteRequest2Table.ID1))
				 and RouteRequest2Table.ID2 = (5 -> pre(RouteRequest2Table.ID2))
				 and RouteRequest2Table.ID3 = (6 -> pre(RouteRequest2Table.ID3))
				 and RouteRequest2Table.sent_ID1 = (false -> (pre(RouteRequest2Table.sent_ID1) 
				 						or (event(RoutePlanRequest_out) 
				 								and RoutePlanRequest_out.RequestID = RouteRequest2Table.ID1)))
				 and RouteRequest2Table.sent_ID2 = (false -> (pre(RouteRequest2Table.sent_ID2) 
				 						or (event(RoutePlanRequest_out) 
				 								and RoutePlanRequest_out.RequestID = RouteRequest2Table.ID2)))
				 and RouteRequest2Table.sent_ID3 = (false -> (pre(RouteRequest2Table.sent_ID3) 
				 						or (event(RoutePlanRequest_out) 
				 								and RoutePlanRequest_out.RequestID = RouteRequest2Table.ID3)))
				 and RouteRequest2Table.recd_ID1 = (false -> (pre(RouteRequest2Table.recd_ID1)
				 						or (event(RoutePlanResponse_in) 
				 								and RoutePlanResponse_in.ResponseID = RouteRequest2Table.ID1)))
				 and RouteRequest2Table.recd_ID2 = (false -> (pre(RouteRequest2Table.recd_ID2)
				 						or (event(RoutePlanResponse_in) 
				 								and RoutePlanResponse_in.ResponseID = RouteRequest2Table.ID2)))
				 and RouteRequest2Table.recd_ID3 = (false -> (pre(RouteRequest2Table.recd_ID3)
				 						or (event(RoutePlanResponse_in) 
				 								and RoutePlanResponse_in.ResponseID = RouteRequest2Table.ID3)))
				  and RouteRequest2 = RouteRequest_in); 
				 
		guarantee "Intial table for the third received route request" :
			(event(RouteRequest_in) and totalRouteRequestsReceivedCounter=3) =>  
				  (RouteRequest3Table.number_of_requests = RouteRequest_in.NumVehicleIDs
				and RouteRequest3Table.ID1 = (7 -> pre(RouteRequest3Table.ID1))
				and RouteRequest3Table.ID2 = (8 -> pre(RouteRequest3Table.ID2))
				and RouteRequest3Table.ID3 = (9 -> pre(RouteRequest3Table.ID3))
				and RouteRequest3Table.sent_ID1 = (false -> (pre(RouteRequest3Table.sent_ID1) 
				 						or (event(RoutePlanRequest_out) 
				 								and RoutePlanRequest_out.RequestID = RouteRequest3Table.ID1)))
				and RouteRequest3Table.sent_ID2 = (false -> (pre(RouteRequest3Table.sent_ID2) 
				 						or (event(RoutePlanRequest_out) 
				 								and RoutePlanRequest_out.RequestID = RouteRequest3Table.ID2)))
				and RouteRequest3Table.sent_ID3 = (false -> (pre(RouteRequest3Table.sent_ID3) 
				 						or (event(RoutePlanRequest_out) 
				 								and RoutePlanRequest_out.RequestID = RouteRequest3Table.ID3)))
				and RouteRequest3Table.recd_ID1 = (false -> (pre(RouteRequest3Table.recd_ID1)
				 						or (event(RoutePlanResponse_in) 
				 								and RoutePlanResponse_in.ResponseID = RouteRequest3Table.ID1)))
				and RouteRequest3Table.recd_ID2 = (false -> (pre(RouteRequest3Table.recd_ID2)
				 						or (event(RoutePlanResponse_in) 
				 								and RoutePlanResponse_in.ResponseID = RouteRequest3Table.ID2)))
				and RouteRequest3Table.recd_ID3 = (false -> (pre(RouteRequest3Table.recd_ID3)
				 						or (event(RoutePlanResponse_in) 
				 								and RoutePlanResponse_in.ResponseID = RouteRequest3Table.ID3)))
				and RouteRequest3 = RouteRequest_in);
		--and so on
		
		--These guarantees should no longer be necessary by adding "pre" expressions above
--		guarantee "Table 1's IDs stay the same once set" :
--			not (event(RouteRequest_in) and totalRouteRequestsReceivedCounter=1) => 
--				((RouteRequest1Table.ID1 = 
--					(0 -> pre(RouteRequest1Table.ID1)))
--					and (RouteRequest1Table.ID2 = 
--							(0 -> pre(RouteRequest1Table.ID2)))
--					and (RouteRequest1Table.ID3 = 
--							(0 -> pre(RouteRequest1Table.ID3)))
--				);	
--				
--		guarantee "Table 2's IDs stay the same once set" :
--			not (event(RouteRequest_in) and totalRouteRequestsReceivedCounter=2) => 
--				((RouteRequest2Table.ID1 = 
--					(0 -> pre(RouteRequest2Table.ID1)))
--					and (RouteRequest2Table.ID2 = 
--							(0 -> pre(RouteRequest2Table.ID2)))
--					and (RouteRequest2Table.ID3 = 
--							(0 -> pre(RouteRequest2Table.ID3)))
--				);
--				
--		guarantee "Table 3's IDs stay the same once set" :
--			not (event(RouteRequest_in) and totalRouteRequestsReceivedCounter=3) => 
--				((RouteRequest3Table.ID1 = 
--					(0 -> pre(RouteRequest3Table.ID1)))
--					and (RouteRequest3Table.ID2 = 
--							(0 -> pre(RouteRequest3Table.ID2)))
--					and (RouteRequest3Table.ID3 = 
--							(0 -> pre(RouteRequest3Table.ID3)))
--				);
--		--and so on
		
		--NOTE: due to other timing bounds assumptions, each new RouteRequest_in 
		--must emit all RoutePlanRequests_out before a new RouteRequest_in is allowed. 
		--This counter keeps track of plan requests sent out based on this assumption. 
		eq num_of_route_plan_requests_sent_for_current_route_request : int = 
			if (event(RouteRequest_in)) then 
				0 
			else ((0 -> pre(num_of_route_plan_requests_sent_for_current_route_request)) 
							+ UxAS_Node_Lib.bool_to_int(event(RoutePlanRequest_out)));
		

	--NOTE: macros that examine the "chicklist table" to determine if all RoutePlanResponses have been received. 
	--for each RouteRequest_in
		eq RouteRequest1Table_all_plans_received : bool = 
				RouteRequest1Table.number_of_requests = 
					(Uxas_Node_Lib.bool_to_int(RouteRequest1Table.recd_ID1) +
					Uxas_Node_Lib.bool_to_int(RouteRequest1Table.recd_ID2) + 
					Uxas_Node_Lib.bool_to_int(RouteRequest1Table.recd_ID3));
				
		eq RouteRequest2Table_all_plans_received : bool = 
				RouteRequest2Table.number_of_requests = 
					(Uxas_Node_Lib.bool_to_int(RouteRequest2Table.recd_ID1) +
					Uxas_Node_Lib.bool_to_int(RouteRequest2Table.recd_ID2) + 
					Uxas_Node_Lib.bool_to_int(RouteRequest2Table.recd_ID3));
				
		eq RouteRequest3Table_all_plans_received : bool = 
				RouteRequest3Table.number_of_requests = 
					(Uxas_Node_Lib.bool_to_int(RouteRequest3Table.recd_ID1) +
					Uxas_Node_Lib.bool_to_int(RouteRequest3Table.recd_ID2) + 
					Uxas_Node_Lib.bool_to_int(RouteRequest3Table.recd_ID3));
				
		--NOTE: going to be problematic if they can occur simultanouesly 
		guarantee "Only send a RouteResponse when all expected RoutePlanResponses are received for a given RouteRequest_in.
				Only one RouteResponse_out is generate for each RouteRequest_in." : 
			if (not pre(RouteRequest1Table_all_plans_received) and RouteRequest1Table_all_plans_received ) then
				event(RouteResponse_out) and RouteResponse_out.ResponseID = RouteRequest1.RequestID
			else if (not pre(RouteRequest2Table_all_plans_received) and RouteRequest2Table_all_plans_received) then
				event(RouteResponse_out) and RouteResponse_out.ResponseID = RouteRequest2.RequestID
			else if (not pre(RouteRequest3Table_all_plans_received) and RouteRequest3Table_all_plans_received) then
				event(RouteResponse_out) and RouteResponse_out.ResponseID = RouteRequest3.RequestID
			--and so on
			else
				not event(RouteResponse_out) ;
	
	
		--TODO: how do I make RoutePlanRequest_out occur exclusively 
		guarantee "The RequestID in a RoutePlanRequest_out message is an ID in the table for which we have not sent
					a route plan request yet" :
			if (event(RoutePlanRequest_out) and num_of_route_plan_requests_sent_for_current_route_request=1) then
				 RoutePlanRequest_out.RequestID = last_route_request_table.ID1
			else if (event(RoutePlanRequest_out) and num_of_route_plan_requests_sent_for_current_route_request=2) then
				RoutePlanRequest_out.RequestID = last_route_request_table.ID2
			else --(event(RoutePlanRequest_out) and num_of_route_plan_requests_sent_for_current_route_request=3) 
				RoutePlanRequest_out.RequestID = last_route_request_table.ID3;
			--and so on
						
		-- Note: the comments below are from prior versions of the aggregator

		-- Q: Is the ResponseID in the route plan responses enough to ensure the message is the response we're expecting? 
		-- Do we have any system-level guarantees about uniqueness of these IDs? 
		-- A from Derek: No.
		-- All agreed it may be an issue that two tasks could make a request with the same ID. 
		--  They would both think the response is for them. And this service could be confused too.
			
		------------------------------------------------------------
		-- Below is some Q&A. Discussion held 6/13/17 with Jen, Aaron, Sean, Ben R., and John B. 
		
		-- Q: What will the top-level UxAS use from this? It doesn't have visibility into the internal state... 
		-- John: Modeling the state makes sense if we have a system-level guarantee that references it.
		-- Ben: Higher level req may be if all responses are received, response is sent out.
		-- John: We could try to figure out our system-level reqts first and model the Wiki more coarsely.
		
		-- Q (Philosophical): Should component contracts include only what we need for architectural level reasoning,
		--  or should the contracts be sufficiently detailed so that any component satisfying the contract will
		--  result in a correctly functioning system? Or would one argue that these are in fact the same?
		-- John: In general, a component contract should have at least enough info to prove system-level reqts.
		-- 	Component reqts need to trace to some system reqt.
		-- Ben: But sometimes we build components out of context. Maybe some are identified for "plug-and-play." Those may
		--  be over-designed.
		-- Aaron: Contracts should ensure that a replacement component gives us the same functionality that we had 
		--  previously. 
		 
		--  Currently, my contracts on this component are not nearly sufficient to ensure correctness. The output
		--  messages could be jibberish. Even if I require the response ID to match the request ID, the
		--  rest of the information could be garbage.
		
		
		--------------------
		-- Timing Properties
		--------------------
		--Response to RouteRequest_in
		-- idle -> pending, indexed by RouteRequest request ID, create a checklist of expected responses. 
		-- Emit a number of RoutePlanRequest messages equal to the number of vehicles in the VehicleID field of 
		--the original RouteRequest
		-- Note: states IDLE and PENDING were removed in this version of the aggregator. 

		eq event_RouteRequest_in : bool = event(RouteRequest_in);
		eq event_RoutePlanRequest_out : bool = event(RoutePlanRequest_out);
								
		eq all_RoutePlanRequests_sent_for_last_route_request : bool = 
			last_route_request_table.number_of_requests = num_of_route_plan_requests_sent_for_current_route_request;

		--TODO: start with assuming one plan per request
		--ASK DEREK: one request at a time or all requests at once? 
			--Confirmed by Derek: timing for all requests at once
		guarantee "When a RouteRequest_in is received, all corresponding RoutePlanRequest_out messages are sent (one
			for each vehicle in the RouteReuqest_in) no later than 1ms following reception of the RouteRequest_in." : 
			whenever event_RouteRequest_in occurs all_RoutePlanRequests_sent_for_last_route_request occurs during [0.0,0.001];
			
		--RoutePlanResponse_in occurs
		--Store response and check to see if this message completes any checklist. 
		--If a checklist is complete, use the corresponding request ID to create a
		-- complete RouteResponse message. Emit RouteResponse and pending -> idle.

		--NOTE: I don't believe Agree provides XOR, having to express XOR in "longhand"
		--NOTE: I wanted to express that a RouteResponse_out is produced for every complete "checklist",
		--without xor it appeared the spec was saying that it was acceptable to have traces where 
		--two checklists complete at the same time yet only one response is sent. 
	
		eq individual_route_request_checklist_complete : bool = 
					  ((RouteRequest1Table_all_plans_received and not pre(RouteRequest1Table_all_plans_received))
						and not (RouteRequest2Table_all_plans_received and not pre(RouteRequest2Table_all_plans_received))
						and not (RouteRequest3Table_all_plans_received and not pre(RouteRequest3Table_all_plans_received)))
					or ((RouteRequest2Table_all_plans_received and not pre(RouteRequest2Table_all_plans_received))
						and not (RouteRequest1Table_all_plans_received and not pre(RouteRequest1Table_all_plans_received))
						and not (RouteRequest3Table_all_plans_received and not pre(RouteRequest3Table_all_plans_received)))
					or ((RouteRequest3Table_all_plans_received and not pre(RouteRequest3Table_all_plans_received))
						and not (RouteRequest2Table_all_plans_received and not pre(RouteRequest2Table_all_plans_received))
						and not (RouteRequest1Table_all_plans_received and not pre(RouteRequest1Table_all_plans_received)));
	
		eq event_RouteResponse_out : bool = event(RouteResponse_out);
		guarantee "When the set of all expected RoutePlanResponse_in messages is received for a given RouteRequest_in, 
			a RouteResponse_out message is emitted no later than 1ms following reception of the final satisfying RoutePlanResponse_in.":
		whenever individual_route_request_checklist_complete occurs event_RouteResponse_out occurs during [0.0,0.001];


	**};
end RouteAggregatorService_AggregatorRole;

-- Thought from Derek: It would be valuable to do some (simple) functions in AADL implementations. But 
--   keep things like route planning to code rather than implementing here.
--   Think about what could be moved here for message processing, state machines, etc.


end RouteAggregatorService_AggregatorRole_Pkg;
	
