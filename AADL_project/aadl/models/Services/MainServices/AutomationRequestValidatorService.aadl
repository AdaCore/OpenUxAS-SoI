package AutomationRequestValidatorService_Pkg
public
    -- Include DataTypes
    with CMASI;
    with UXTASK;
    with IMPACT;
    
    	-- This is a "dummy" top-level system. We use it so that we can check 
	--  "properties" of our component contract.
	process top_level
		annex agree {**
			guarantee "Placeholder guarantee to force agree to run" : true;
		**};
	end top_level;
	
	process implementation top_level.Impl
		subcomponents
			sub : thread AutomationRequestValidatorService; 
		annex agree {**
			-- These lemmas could be captured in SpeAR as properties
			
			--States to check for reachability:
			    -- IDLE
			    -- BUSY
			
			-- These lemmas could be captured in SpeAR as oberservers (without the negation)
			lemma "False indicates the IDLE state is reachable" : sub.state != sub.IDLE; 
			lemma "False indicates the BUSY state is reachable" : sub.state != sub.BUSY; --NOTE: initially found this was unreachable
			
			lemma "True indicates we have enumerated all states in the reachability observers" :
				sub.state = sub.IDLE or
				sub.state = sub.BUSY;	
				
			lemma "False indicates idle_to_busy transition is reachable" : 
           		 sub.idle_to_busy;
           		 
           	lemma "False indicates busy_to_idle transition is reachable" : 
           		 sub.busy_to_idle;	
           		 
           	lemma "True if only stated transitions are executed (no missing transitions)." :
                sub.some_transition or sub.state = sub.previous_state;	
				
			lemma "True indicates the queue can never go negative" : 
            	sub.numTasksInQ >= 0;
            lemma "False indicates the queue can potentially be greater than 0" : 
            	sub.numTasksInQ = 0;
            	
		**};
	end top_level.Impl;	
	
    
    thread AutomationRequestValidatorService
        features
            TaskInitialized_in: in event data port uxtask::TaskInitialized.i;
            KeepOutZone_in: in event data port cmasi::KeepOutZone.i;
            SurfaceVehicleConfiguration_in: in event data port impact::SurfaceVehicleConfiguration.i;
            AirVehicleConfiguration_in: in event data port cmasi::AirVehicleConfiguration.i;
            AreaOfInterest_in: in event data port impact::AreaOfInterest.i;
            AutomationRequest_in: in event data port cmasi::AutomationRequest.i;
            GroundVehicleState_in: in event data port impact::GroundVehicleState.i;
            TaskAutomationRequest_in: in event data port uxtask::TaskAutomationRequest.i;
            UniqueAutomationResponse_in: in event data port uxtask::UniqueAutomationResponse.i;
            PointOfInterest_in: in event data port impact::PointOfInterest.i;
            RemoveTasks_in: in event data port cmasi::RemoveTasks.i;
            Task_in: in event data port cmasi::Task.i;
            OperatingRegion_in: in event data port cmasi::OperatingRegion.i;
            GroundVehicleConfiguration_in: in event data port impact::GroundVehicleConfiguration.i;
            AirVehicleState_in: in event data port cmasi::AirVehicleState.i;
            SurfaceVehicleState_in: in event data port impact::SurfaceVehicleState.i;
            KeepInZone_in: in event data port cmasi::KeepInZone.i;
            ImpactAutomationRequest_in: in event data port impact::ImpactAutomationRequest.i;
            LineOfInterest_in: in event data port impact::LineOfInterest.i;
                    --note that the code does not acually subscribe to "ServiceStatus" currently
            ServiceStatus_in: in event data port cmasi::ServiceStatus.i;
                    --the source code subscribes to all descendants of task:
            SearchTask_in: in event data port cmasi::SearchTask.i;
            AreaSearchTask_in: in event data port cmasi::AreaSearchTask.i;
            LineSearchTask_in: in event data port cmasi::LineSearchTask.i;
            LoiterTask_in: in event data port cmasi::LoiterTask.i;
            MustFlyTask_in: in event data port cmasi::MustFlyTask.i;
            PointSearchTask_in: in event data port cmasi::PointSearchTask.i;
            ServiceStatus_out: out event data port cmasi::ServiceStatus.i;
            ImpactAutomationResponse_out: out event data port impact::ImpactAutomationResponse.i;
            AutomationResponse_out: out event data port cmasi::AutomationResponse.i;
            TaskAutomationResponse_out: out event data port uxtask::TaskAutomationResponse.i;
            UniqueAutomationRequest_out: out event data port uxtask::UniqueAutomationRequest.i;
        properties
            Dispatch_Protocol => Sporadic;
            
            
        annex agree {**
        --Questions: 
            --Is the system idle when waiting for a response?
                --Busy defined with respect to "servicing" a request, not the queue size? 
            --Does the system move on to the next task before receiving a response? 
            --Is it possible to recieve a response that does not match the request? 
                --Is this an error? 
            --What is an error message?
                
            --States
            const IDLE : int = 0;
            const BUSY : int = 1;
            
            --TODO: possible third or intermediate state? 
            -- All vehicles requested exist, task requested exists, flight regions actually exist. 
            
            --previous received an airvehicle ID, airvehicle state
                --AirVehicleConfiguration_in and AirVehicleState_in
            --task requested exists
                --TaskInitialized_in
            -- regions
                -- OperatingRegion_in
                -- KeepInZone_in
                -- KeepOutZone_in
        
        -------------------------------------------------------------
        --State machine support macros
            eq previous_state: int = prev(state,IDLE);
            eq some_transition: bool = idle_to_busy
                                    or busy_to_idle;
        -------------------------------------------------------------
        
        --****ISSUE: what is a received automation request: what type?****
        ---------------- state transitions ----------------
            eq idle_to_busy : bool = false -> 
                previous_state = IDLE and 
                event(AutomationRequest_in) and  
                taskVehicleOrRegionIsDefined;
            
            eq busy_to_idle : bool = false -> 
                (previous_state = BUSY and 
                dequeue_trigger and
                numTasksInQ = 0);
        ---------------- end state transitions ----------------
                
            eq dequeue_trigger : bool = false -> 
                (event(UniqueAutomationResponse_in) and UniqueAutomationResponse_in.ResponseID = cached_unique_automation_request_id and not uniqueAutomationRequestErrorMessageRecieved) or
                timer_threshold_reached or 
                received_error_message;
                
            eq timer_threshold_reached : bool = false -> 
                timeout_option and 
                timer>=timeout_threshold;
                
            eq received_error_message : bool = false ->
                --TODO: Derek is going to update the spec to have a unique automation error response in
                --check the error response to match the cached ID, if matched there is an error. 
                event(UniqueAutomationResponse_in) and 
                UniqueAutomationResponse_in.ResponseID = cached_unique_automation_request_id and
                uniqueAutomationRequestErrorMessageRecieved; --represents a flag indicating error for now
                
            eq timer : int;
            eq timeout_threshold : int;
            eq timeout_option : bool;
            eq state : int;
            eq cached_unique_automation_request_id : int;
            
            const SERVICE_TYPE_ERROR_SIGNAL : int = 2;
            
            eq timer_reset: bool = true-> 
                event(UniqueAutomationRequest_out) or --Timer starts once we ask for a response (make a request)
                state=IDLE or 
                (event(UniqueAutomationResponse_in) and 
                UniqueAutomationResponse_in.ResponseID  = cached_unique_automation_request_id); 
            
            -- a non-deterministic variable used to model whether or not 
            -- the requested task, vehicle, or operating region has been defined.
            eq taskVehicleOrRegionIsDefined : bool;
            
            eq uniqueAutomationRequestErrorMessageRecieved : bool; --????

            eq numTasksInQ : int;
            
            guarantee "Self loops": not some_transition => (state = previous_state);
                
            guarantee "Initially the task queue is empty" :
                (numTasksInQ = 0) -> true;
    
            guarantee "Implied Spec: Initially, the service is idle" :
                (state = IDLE) -> true;
                
            guarantee "[Implied: is this necessary? in IDLE the numTasksInQ is 0]" :
                state = IDLE =>
                    numTasksInQ = 0;
            
            --TODO make error message a new variable. 
            
            --TODO: check request resource definition instead of non deterministic boolean? 
            --TODO: is it worth modeling the local state of what the service maintains? 
            guarantee "if automation request is received and the requested resource has not been defined then we produce an error" : true ->
                event(TaskAutomationRequest_in) and not taskVehicleOrRegionIsDefined => 
                    --TODO: derek will add automation request
                    event(ServiceStatus_out) and 
                    ServiceStatus_out.StatusType = SERVICE_TYPE_ERROR_SIGNAL; --and 
                    --numTasksInQ = pre(numTasksInQ);
                    --TODO: what about the timer? 
                    --TODO: apparently the code sets the status type to "information" rather than "error"
                
            --Note: the original wording of this guarantee implies the unique automation request is only sent
            --out when the system is IDLE. I am manually altering the original "spec" to speak to what I believe
            --was intended
            --Note: the wording "immediately" seems to imply it is ok to immediately raise the event instead of using the
            --"eventually" idiom. 
            guarantee "if automation request is received and resource is defined produce unique automation request.
            If in the idle state, this service will immediately publish the UniqueAutomationRequest message and transition to the busy state.": true ->
                idle_to_busy =>
                --QUESTION: what is a automation request? above it is listed as a task automation request
                    event(UniqueAutomationRequest_out) and state = BUSY and
                    cached_unique_automation_request_id = UniqueAutomationRequest_out.RequestID; --Used for subsequent specs
            
            guarantee "[NOTE: extension of the above spec] If already in the busy state, the UniqueAutomationRequest will be added to the end of a queue.":
                  state = BUSY =>
                  --Note: the definition of the idle state suggests numTasksInQ should already be 0 on transition
                  --the first guarantee in the above if statement is therefore likely redundant, but helpful for reviewers
                  	if previous_state != BUSY and not (event(AutomationRequest_in) and taskVehicleOrRegionIsDefined) then
                  		numTasksInQ = 0
                    else if event(AutomationRequest_in) and taskVehicleOrRegionIsDefined then
                        numTasksInQ = pre(numTasksInQ) + 1
                    else
                        numTasksInQ = pre(numTasksInQ);
                   
--              pre(event(TaskAutomationRequest_in) and taskVehicleOrRegionIsDefined) =>
--                  state = BUSY and numTasksInQ = pre(numTasksInQ) + 1;
--                  if pre(state = IDLE) then 
--                      event(UniqueAutomationRequest_out) and state = BUSY --and numTasksInQ = 0
--                  else --state = BUSY
--                     state = BUSY and numTasksInQ = pre(numTasksInQ) + 1;
                       
            --Note: forcing an incrementing timer (unspecified increment) for now
            guarantee "Service includes an optional timeout. When a UniqueAutomationRequest is published, a timer begins" : true ->
                timeout_option => 
                    if timer_reset then
                        timer = 0
                    else 
                        timer > pre(0->timer);
                        
            --TODO: is this service validating "requests" while queued or only when requests are being actively serviced.
            
            guarantee "If the queue is empty, this service transitions back to the idle state. 
            [Implied, that the transition occurs also based on a response, timeout, or error message, i.e., a dequeue trigger]" :
                busy_to_idle => 
                    state = IDLE;
                    
            guarantee "[Implied Requirement: process next message only if IDLE or a response has been received]":
                 state = BUSY and dequeue_trigger and pre(numTasksInQ) >0 =>
                    --NOTE: no checking that the event is for the next item in the queue.
                    --TODO: can mimic queue if the ID's are incremented by one, I can force what the message refers to (1 minus current)
                        event(UniqueAutomationRequest_out) and 
                        numTasksInQ = pre(numTasksInQ) - 1 and
                        cached_unique_automation_request_id = UniqueAutomationRequest_out.RequestID;

            --TODO: unclear if ths is the error message behavior specified
            guarantee "When this service receives either an error message 
            (indicating that the UniqueAutomationRequest cannot be fulfilled or 
                a corresponding UniqueAutomationResponse), it will publish the same message. " : true ->
                received_error_message => 
                    event(AutomationResponse_out) and --TODO: will become an automation response error out at some point
                    (event(ServiceStatus_out) and ServiceStatus_out.StatusType = SERVICE_TYPE_ERROR_SIGNAL) ;
                    
                    
--          --Cannot formalize in AGREE (unlesse I create a counter)
--          guarantee "The request ID of unique automation responses are unique" :
--              true;
--              
--          --Not sure if there is a way to model this property in agree
--          guarantee "tasks are fed into 'the system' one at a time" : 
--              true; --What was meant was to mean "the queue", might not be necessary
                    
        **};
    end AutomationRequestValidatorService;
    
end AutomationRequestValidatorService_Pkg;
