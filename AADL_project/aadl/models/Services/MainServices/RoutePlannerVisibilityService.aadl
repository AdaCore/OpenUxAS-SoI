package RoutePlannerVisibilityService_Pkg
public
    -- Include DataTypes
    with CMASI;
    with IMPACT;
    with ROUTE;
    
   -- This is a "dummy" top-level system. We use it so that we can check 
	--  properties of our component contract, states as lemmas in the top_level implementation.
	process top_level
		annex agree {**
			guarantee "Placeholder guarantee to force agree to run" : true;
		**};
	end top_level;
	
	process implementation top_level.Impl
		subcomponents
			sub : thread RoutePlannerVisibilityService; 
		annex agree {**
			-- These lemmas could be captured in SpeAR as properties
			-- TBD
			lemma "Placeholder lemma so that AGREE/OSATE can build the part's controls." : true;
			-- These lemmas could be captured in SpeAR as oberservers (without the negation)
			-- TBD
			
		**};
		 
	end top_level.Impl;	
    
    thread RoutePlannerVisibilityService
        features
            GroundVehicleConfiguration_in: in event data port impact::GroundVehicleConfiguration.i;
            SurfaceVehicleConfiguration_in: in event data port impact::SurfaceVehicleConfiguration.i;
            KeepOutZone_in: in event data port cmasi::KeepOutZone.i;
            AirVehicleConfiguration_in: in event data port cmasi::AirVehicleConfiguration.i;
            RoutePlanRequest_in: in event data port route::RoutePlanRequest.i;
            RouteRequest_in: in event data port route::RouteRequest.i;
            GroundVehicleState_in: in event data port impact::GroundVehicleState.i;
            KeepInZone_in: in event data port cmasi::KeepInZone.i;
            OperatingRegion_in: in event data port cmasi::OperatingRegion.i;
            AirVehicleState_in: in event data port cmasi::AirVehicleState.i;
            SurfaceVehicleState_in: in event data port impact::SurfaceVehicleState.i;
            RoutePlanResponse_out: out event data port route::RoutePlanResponse.i;
        properties
            Dispatch_Protocol => Sporadic;
        annex agree {**
        	-- What does correct mean for this component? The Wiki talks about how the route planner works,
        	--  as well as the importance of efficiency. I don't think we want to specify how this route planner
        	--  works (design), but we should strive to specify what it means for a route planner to be correct.
        	
        	--Q: Both RouteRequest_in and RoutePlanRequest_in are listed as inputs here, but the Wiki only lists
        	-- RoutePlanRequest_in. Which is correct?
        	--TODO: Check the code to answer this question.
        	
        	-----------------------------------------------
        	--Here are some easy guarantees for fields that simply need to match those in the request	
             	        		
        	guarantee "The ResponseID in the response matches the RequestID in the request.":
        		event(RoutePlanResponse_out) => 
        			(RoutePlanResponse_out.ResponseID = RoutePlanRequest_in.RequestID);
        	
        	guarantee "The AssociatedTaskID in the response matches the AssociatedTaskID in the request.":
        		event(RoutePlanResponse_out) =>
        			(RoutePlanResponse_out.AssociatedTaskID = RoutePlanRequest_in.AssociatedTaskID);
        	
        	guarantee "The VehicleID in the response matches the VehicleID in the request.":
        	    event(RoutePlanResponse_out) => 
        			(RoutePlanResponse_out.VehicleID = RoutePlanRequest_in.VehicleID);
        			
        	guarantee "The OperatingRegion in the response matches the OperatingRegion in the request.":
        	    event(RoutePlanResponse_out) => 
        			(RoutePlanResponse_out.OperatingRegion = RoutePlanRequest_in.OperatingRegion);
        	-----------------------------------------------
        	      		
        	-- Q: This service processes only one request at a time. Should we assume it does this on one timestep?
        	-- Should we require it completes the job within some set amount of time?
        	-- If we can assume that we can respond in one timestep, then we don't need to store the request or worry about 
        	--  what to do if we get another request before we're done servicing the one we're working on.
        	--  I'll make a one-timestep draft and will relax that assumption if needed after a team discussion.
        	
        	--I made this an if and only if. And the response occurs on the next timestep.
        	guarantee "A RoutePlanResponse is produced whenever a RoutePlanRequest is received.":
        		event(RoutePlanResponse_out) = (false -> pre(event(RoutePlanRequest_in)));
        		
        	--I don't have any guarantees regarding the other inputs to this component.        	
        	--Q: What, if anything, should we say about those?
        	
        	--The "holy grail" guarantee for this service is something like this:
        	-- Each route plan produced by this service:
        	--	(a) satisfies the corresponding route constraint in the route plan request message,
        	--  (b) adheres to the keep in and keep out zones included in the requested OperatingRegion, and
        	--  (c) is a "flyable" route for the vehicle, given the vehicle's configuration.
        	--It is not easy to specify something like this. For example, the correctness statement for 
        	-- detecting conflict between two moving air vehicles (moving circle avoidance region) is this:
        	--  There is a 2-dimenstional conflict in [B,T] if and only if there exists a time t in [B,T] such that
        	--  the relative ownship position s+t*v is strictly less than D from the origin, i.e., if and only if the 
        	--  Euclideant norm ||s+t*v|| < D, where D is the horizontal buffer, s and v are the position and velocity
        	--  of the ownship relative to the intruder.
        	-- And this does not even take into account multiple vehicles or multiple waypoints on a flightplan 
        	--  (both of which require iteration and using the spec above)!
        	
        	--Here are some placeholder guarantees using Booleans for what we really want.
        	
        	eq each_route_satisfies_the_route_constraint : bool;
        	guarantee "Each route produced satisfies the corresponding route constraint in the route plan request":
        		event(RoutePlanResponse_out) => 
        			each_route_satisfies_the_route_constraint;
        	
        	--  For starters, the start and end locations should match those in the request, unless an 
        	--   error is returned; but I need to access the arrays to formally express this 
        	--   (beyond using a Boolean variable set to true).
        	eq first_and_last_waypoints_in_each_route_plan_match_those_requested: bool;
        	guarantee "First and last waypoints in each route plan in the route plan response match the start location
        		and end location in the corresponding route constraint in the route plan request":
        		event(RoutePlanResponse_out) => 
        			first_and_last_waypoints_in_each_route_plan_match_those_requested;
        	
        	eq each_route_adheres_to_the_operating_region : bool;
        	guarantee "Each route produced adheres to the keep in and keep out zones in the operating region":
        		event(RoutePlanResponse_out) => 
        			each_route_adheres_to_the_operating_region;
        	
        	eq each_route_is_flyable_per_the_vehicle_configuration_and_state : bool;
        	guarantee "Each route is flyable per the vehicle configuration and state":
        		event(RoutePlanResponse_out) => 
        			each_route_is_flyable_per_the_vehicle_configuration_and_state;
        	
        **};
    end RoutePlannerVisibilityService;
    
end RoutePlannerVisibilityService_Pkg;
